[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "La biologie est une discipline qui étudie des sujets complexes : les être vivants. Cette complexité est due aux très nombreuses interactions entre les “briques” qui composent les être vivants, à différentes échelles : les interactions chimiques entre les atomes, les molécules, les protéines, les cellules, les tissus, les organes et même entre les individus. Ainsi, il est difficile d’étudier l’effet d’une protéine sans comprendre ses interactions avec le reste de l’organisme, il faut donc prendre en compte tout l’environnement autour du sujet d’étude pour bien le comprendre. \nDans le domaine de la Recherche Clinique, on dit souvent que pour développer UN médicament, il faut screener 10.000 molécules. C’est parce que pour 10.000 molécules prometteuses sur le papier, en réalité seules 1.000 environ démontreront une efficacité sur des cellules isolées. Parmis ces 1.000, seules 100 montreront une efficacité dans les tests précliniques (organes, animaux), et seules 10 passeront à l’étape d’expérimentation sur l’humain, pour finalement avoir une molécule qui finira en médicament. \nPour illustrer cela, on peut prendre l’exemple d’une boîte de petri qui contiendrait des tissus cancéreux : y mettre le feu permet de détruire les cellules cancéreuses, mais n’en fait pas un bon traitement pour autant : il faut prendre en compte le contexte dans lequel l’objet d’étude évolue (ici, en l’occurrence : le corps humain) \nMais dans un génome qui fait 3.2 milliards de paires de bases, il est difficile de retenir toutes les interactions entre les différents gènes, ou même de simplement les lister. L’informatique est alors apparue comme une solution, dans un premier temps de stockage et de requêtage, puis de calcul et de visualisation, pour aller jusqu’à permettre aujourd’hui d’effectuer des prédictions.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#programmer-cest-quoi",
    "href": "index.html#programmer-cest-quoi",
    "title": "Introduction",
    "section": "Programmer, c’est quoi ?",
    "text": "Programmer, c’est quoi ?\nLa programmation, c’est donner des instructions à un ordinateur, comme on donnerait des instructions à une calculatrice pour faire un calcul. \nOn parle de langages de programmation car les instructions que l’on utilise sont proches du langage naturel. Par exemple, on comprendra facilement que la commande “cos(5)” indique d’effectuer le calcul “cosinus de 5”.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#un-peu-dhistoire",
    "href": "index.html#un-peu-dhistoire",
    "title": "Introduction",
    "section": "Un peu d’histoire",
    "text": "Un peu d’histoire\nLes premières années de l’informatique remontent vers 1890, lorsque Herman Hollerith (futur fondateur d’IBM) dépose un brevet pour une machine à calculer en se basant sur les travaux de Charles Babbage et Ada Lovelace (1842). L’objectif était d’aider au recensement des Etats-unis en automatisant les calculs, car à cette époque le recensement était réalisé tous les dix ans et nécessitait neuf ans de travail.\nLes machines à calculer, appelés tabulatrices étaient électro-mécaniques et disposaient de programmes “fixes” : la machine contenait un panneau de contrôle, dans lequel le fabriquant avait “écrit” les instructions en suivant un schéma de câblage. Une machine à calculer était grosse comme un bureau et ne pouvait exécuter qu’un seul programme. Les données étaient saisies sur des cartes perforées et lues en direct par la machine. La carte perforée était lue via des aiguilles qui passaient (ou non) au travers des perforations, puis atterissaient dans un bain de mercure pour fermer un circuit électrique.\n\n\n\n\n\n\n\n\n\nCarte perforée, inspirée des tickets de trains poinçonnés en fonction de l’âge et du sexe des voyageurs\n\n\n\n\n\n\n\nTabulatrice IBM 401, 1948\n\n\n\n\n\nPar la suite, des panneaux de contrôle amovibles sont apparus : pour changer de programme informatique, on changeait le panneau de contrôle. \n\n\n\n\n\n\n\n\n\nPanneau de contrôle d’une tabulatrice\n\n\n\n\n\n\n\nPanneau de contrôle d’une tabulatrice câblé\n\n\n\n\n\n\n\nSchéma du panneau de contrôle d’une tabulatrice\n\n\n\n\n\nDans les années 1960, l’arrivée des transistors permet le début des sytèmes 100% électriques, on change alors de paradigme : un processeur unique permet de faire tous les calculs, et l’utilisateur définit le programme. Cependant, les ordinateurs ne disposent pas encore de mémoire pour se souvenir des différentes étapes d’un programme, le code était alors lui aussi écrit sur des cartes perforées. \n\n\n\nCarte perforée contenant la ligne d’instruction “IF MOD-G-JAHR NOT NUMERIC MOVE ZERO TO MOD-G-JAHR”, écrite en COBOL, 1959\n\n\nLa question que l’on se pose alors est “Comment ces instructions, sous forme de lettres, permettent à des circuits électriques de faire des calculs ?” \nPour comprendre cela, il faut d’abord expliquer comment les commandes d’un langage de programmation sont lues par l’ordinateur.\nPrenons la commande R suivante : print(“Hello World!”) Lorsque l’on va demander à l’ordinateur d’exécuter cette ligne, il va d’abord la traduire en code machine, composé de 0 et de 1 : c’est la compilation. Le code machine est illisible pour les humains, mais est en fait la traduction du code en Assembleur : un langage partagé par tous les processeurs, et qui décompose chaque fonction en une suite d’instructions basiques. &gt; Cette explication est très simplifiée, mais il serait trop complexe de tout détailler ici\n\n\n\n\n\n\nLes bits\n\n\n\nCe que l’on appelle “0 et 1” sont des bits : la plus petite unité d’information possible. Dans un circuit électrique 1 = du courant électrique qui passe, 0 = un courant très faible\n\n\n\n\n\n\n\n\n\n\n\nUne commande écrite en R, s’exécutant en 39 microsecondes (0.000039 s)\n\n\n\n\n\n\n\nLe même code, en assembleur\n\n\n\n\n\n\n\nLe même code, en langage machine\n\n\n\n\n\nMOV, RAX ou RDI sont des “opcodes” (Operation Code) : ce sont des instructions très simples, envoyées au processeur. Un peu à la manière des codons dans l’ADN, ils indiquent ce qui vient après eux. Par exemple, un codon d’initiation dans l’ADN indique le début d’une séquence codante et initialise la traduction de ce qui vient après, jusqu’à rencontrer un codon STOP. Ici, l’opcode MOV sera toujours suivi d’un autre opcode, et RAX est toujours suivi d’une valeur : c’est comme cela qu’on peut traduire des instructions en une suite de 0 et 1\n\n\n\nTraduction de l’ADN à partir du codon d’initation AUG\n\n\n\nLes OPCODES sont comme des codons : ils indiquent une action. 0 et 1 sont comme les nucléotides Tout comme les nucléotides sont regroupés par 3 pour former des acides aminés, les bits (0 et 1) se rassemblent par groupes (souvent de 8) pour former des octets.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "debuter_r.html",
    "href": "debuter_r.html",
    "title": "Titre page",
    "section": "",
    "text": "Pour programmer en R, on utilise généralement un Environnement de développement, ou IDE, un logiciel qui permet d’écrire du code R et de l’exéctuer, comme RStudio. \n\n\n\nCapture d’écran de RStudio\n\n\n\nL’écran de RStudio est découpé en quatre parties\n\nEn haut à gauche : le script (l’entièreté du code, que l’on pourra enregistrer pour le réutiliser)\nEn haut à droite : l’environnement (indique les données enregistrées)\nEn bas à gauche : la console (exécute le code)\nEn bas à droite : le Viewer : permet de visualiser le résultat du code\n\n\nPour ce cours, vous utiliserez les blocs de code interactifs du document. Grâce à un outil appelé WebR, le code R est traduit en WebAssembly, un langage utilisé par les navigateurs Web.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: note, warning, important, tip, and caution.\n\n\n\n\n\n\n\n\nAstuce\n\n\n\nThis is an example of a callout with a title.\n\n\n\n\n\n\n\n\nExpand To Learn About Collapse\n\n\n\n\n\nThis is an example of a ‘folded’ caution callout that can be expanded by the user. You can use collapse=\"true\" to collapse it by default or collapse=\"false\" to make a collapsible callout that is expanded by default.",
    "crumbs": [
      "Débuter R",
      "Titre page"
    ]
  },
  {
    "objectID": "index.html#la-bioinformatique-pourquoi-faire",
    "href": "index.html#la-bioinformatique-pourquoi-faire",
    "title": "Introduction",
    "section": "",
    "text": "La biologie est une discipline qui étudie des sujets complexes : les être vivants. Cette complexité est due aux très nombreuses interactions entre les “briques” qui composent les être vivants, à différentes échelles : les interactions chimiques entre les atomes, les molécules, les protéines, les cellules, les tissus, les organes et même entre les individus. Ainsi, il est difficile d’étudier l’effet d’une protéine sans comprendre ses interactions avec le reste de l’organisme, il faut donc prendre en compte tout l’environnement autour du sujet d’étude pour bien le comprendre. \nLe problème, c’est que lorsque l’on étudie un brin d’ADN, il est difficile de retenir les noms et les interactions des 3.000.000.000.000 paires de bases de l’ADN humain, surtout avec un papier et un crayon. \nL’informatique est alors apparue comme une solution, dans un premier temps de stockage et de requêtage, puis de calcul, et aujourd’hui de prédiction.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "presentation_1.html#la-bioinformatique-pourquoi-faire",
    "href": "presentation_1.html#la-bioinformatique-pourquoi-faire",
    "title": "presentation R",
    "section": "La bioinformatique, pourquoi faire ?",
    "text": "La bioinformatique, pourquoi faire ?\n\n\nLeft column\n\nRight column\n\n\nNotes du présentateur"
  },
  {
    "objectID": "presentation_1.html#programmer-cest-quoi",
    "href": "presentation_1.html#programmer-cest-quoi",
    "title": "presentation R",
    "section": "Programmer, c’est quoi ?",
    "text": "Programmer, c’est quoi ?\nLa programmation, c’est donner des instructions à un ordinateur, comme on donnerait des instructions à une calculatrice pour faire un calcul. \nOn parle de langages de programmation car les instructions que l’on utilise sont proches du langage naturel. Par exemple, on comprendra facilement que la commande “cos(5)” indique d’effectuer le calcul “cosinus de 5”."
  },
  {
    "objectID": "presentation_1.html#un-peu-dhistoire",
    "href": "presentation_1.html#un-peu-dhistoire",
    "title": "presentation R",
    "section": "Un peu d’histoire",
    "text": "Un peu d’histoire\n\n\n\n\n\n\n\n\n\nCarte perforée, inspirée des tickets de trains poinçonnés en fonction de l’âge et du sexe des voyageurs\n\n\n\n\n\n\n\nTabulatrice IBM 401, 1948"
  },
  {
    "objectID": "L2/debuter_r.html",
    "href": "L2/debuter_r.html",
    "title": "Titre page",
    "section": "",
    "text": "Pour programmer en R, on utilise généralement un Environnement de développement, ou IDE, un logiciel qui permet d’écrire du code R et de l’exéctuer, comme RStudio. \n\n\n\nCapture d’écran de RStudio\n\n\n\nL’écran de RStudio est découpé en quatre parties\n\nEn haut à gauche : le script (l’entièreté du code, que l’on pourra enregistrer pour le réutiliser)\nEn haut à droite : l’environnement (indique les données enregistrées)\nEn bas à gauche : la console (exécute le code)\nEn bas à droite : le Viewer : permet de visualiser le résultat du code\n\n\nPour ce cours, vous utiliserez les blocs de code interactifs du document. Grâce à un outil appelé WebR, le code R est traduit en WebAssembly, un langage utilisé par les navigateurs Web.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: note, warning, important, tip, and caution.\n\n\n\n\n\n\n\n\nAstuce\n\n\n\nThis is an example of a callout with a title.\n\n\n\n\n\n\n\n\nExpand To Learn About Collapse\n\n\n\n\n\nThis is an example of a ‘folded’ caution callout that can be expanded by the user. You can use collapse=\"true\" to collapse it by default or collapse=\"false\" to make a collapsible callout that is expanded by default."
  },
  {
    "objectID": "M2/intro_m2.html",
    "href": "M2/intro_m2.html",
    "title": "Cours M2",
    "section": "",
    "text": "La biologie est une discipline qui étudie des sujets complexes : les être vivants. Cette complexité est due aux très nombreuses interactions entre les “briques” qui composent les être vivants, à différentes échelles : les interactions chimiques entre les atomes, les molécules, les protéines, les cellules, les tissus, les organes et même entre les individus. Ainsi, il est difficile d’étudier l’effet d’une protéine sans comprendre ses interactions avec le reste de l’organisme, il faut donc prendre en compte tout l’environnement autour du sujet d’étude pour bien le comprendre. \nLe problème, c’est que lorsque l’on étudie un brin d’ADN, il est difficile de retenir les noms et les interactions des 3.000.000.000.000 paires de bases de l’ADN humain, surtout avec un papier et un crayon. \nL’informatique est alors apparue comme une solution, dans un premier temps de stockage et de requêtage, puis de calcul, et aujourd’hui de prédiction.\n\n\n\n\n\nLa programmation, c’est donner des instructions à un ordinateur, comme on donnerait des instructions à une calculatrice pour faire un calcul. \nOn parle de langages de programmation car les instructions que l’on utilise sont proches du langage naturel. Par exemple, on comprendra facilement que la commande “cos(5)” indique d’effectuer le calcul “cosinus de 5”. \n\n\n\nLes premières années de l’informatique remontent vers 1890, lorsque Herman Hollerith (futur fondateur d’IBM) dépose un brevet pour une machine à calculer en se basant sur les travaux de Charles Babbage et Ada Lovelace (1842). L’objectif était d’aider au recensement des Etats-unis en automatisant les calculs, car à cette époque le recensement était réalisé tous les dix ans et nécessitait neuf ans de travail.\nLes machines à calculer, appelés tabulatrices étaient électro-mécaniques et disposaient de programmes “fixes” : la machine contenait un panneau de contrôle, dans lequel le fabriquant avait “écrit” les instructions en suivant un schéma de câblage. Une machine à calculer était grosse comme un bureau et ne pouvait exécuter qu’un seul programme. Les données étaient saisies sur des cartes perforées et lues en direct par la machine. La carte perforée était lue via des aiguilles qui passaient (ou non) au travers des perforations, puis atterissaient dans un bain de mercure pour fermer un circuit électrique.\n\n\n\n\n\n\n\n\n\nCarte perforée, inspirée des tickets de trains poinçonnés en fonction de l’âge et du sexe des voyageurs\n\n\n\n\n\n\n\nTabulatrice IBM 401, 1948\n\n\n\n\n\nPar la suite, des panneaux de contrôle amovibles sont apparus : pour changer de programme informatique, on changeait le panneau de contrôle. \n\n\n\n\n\n\n\n\n\nPanneau de contrôle d’une tabulatrice\n\n\n\n\n\n\n\nPanneau de contrôle d’une tabulatrice câblé\n\n\n\n\n\n\n\nSchéma du panneau de contrôle d’une tabulatrice\n\n\n\n\n\nDans les années 1960, l’arrivée des transistors permet le début des sytèmes 100% électriques, on change alors de paradigme : un processeur unique permet de faire tous les calculs, et l’utilisateur définit le programme. Cependant, les ordinateurs ne disposent pas encore de mémoire pour se souvenir des différentes étapes d’un programme, le code était alors lui aussi écrit sur des cartes perforées. \n\n\n\nCarte perforée contenant la ligne d’instruction “IF MOD-G-JAHR NOT NUMERIC MOVE ZERO TO MOD-G-JAHR”, écrite en COBOL, 1959\n\n\nLa question que l’on se pose alors est “Comment ces instructions, sous forme de lettres, permettent à des circuits électriques de faire des calculs ?” \nPour comprendre cela, il faut d’abord expliquer comment les commandes d’un langage de programmation sont lues par l’ordinateur.\nPrenons la commande R suivante : print(“Hello World!”) Lorsque l’on va demander à l’ordinateur d’exécuter cette ligne, il va d’abord la traduire en code machine, composé de 0 et de 1 : c’est la compilation. Le code machine est illisible pour les humains, mais est en fait la traduction du code en Assembleur : un langage partagé par tous les processeurs, et qui décompose chaque fonction en une suite d’instructions basiques. &gt; Cette explication est très simplifiée, mais il serait trop complexe de tout détailler ici\n\n\n\n\n\n\nLes bits\n\n\n\nCe que l’on appelle “0 et 1” sont des bits : la plus petite unité d’information possible. Dans un circuit électrique 1 = du courant électrique qui passe, 0 = un courant très faible\n\n\n\n\n\n\n\n\n\n\n\nUne commande écrite en R, s’exécutant en 39 microsecondes (0.000039 s)\n\n\n\n\n\n\n\nLe même code, en assembleur\n\n\n\n\n\n\n\nLe même code, en langage machine\n\n\n\n\n\nMOV, RAX ou RDI sont des “opcodes” (Operation Code) : ce sont des instructions très simples, envoyées au processeur. Un peu à la manière des codons dans l’ADN, ils indiquent ce qui vient après eux. Par exemple, un codon d’initiation dans l’ADN indique le début d’une séquence codante et initialise la traduction de ce qui vient après, jusqu’à rencontrer un codon STOP. Ici, l’opcode MOV sera toujours suivi d’un autre opcode, et RAX est toujours suivi d’une valeur : c’est comme cela qu’on peut traduire des instructions en une suite de 0 et 1\n\n\n\nTraduction de l’ADN à partir du codon d’initation AUG\n\n\n\nLes OPCODES sont comme des codons : ils indiquent une action. 0 et 1 sont comme les nucléotides Tout comme les nucléotides sont regroupés par 3 pour former des acides aminés, les bits (0 et 1) se rassemblent par groupes (souvent de 8) pour former des octets.\n\n\n\nPour bien comprendre comment des instructions comme “MOV”,“RAX” ou des valeurs comme 20 ou 60 sont transformées et lues sous formes de bits, il faut comprendre le système binaire. \nAu quotidien, on utilise le système décimal : 10 chiffres (0 à 9), puis on passe à une dizaine (10). Le système binaire fonctionne de la même manière, mais n’utilise que 1 et 0. Ainsi, pour compter 0,1,2,3,4,5 en binaire cela donne 0,1,10,11,100,101. On peut visualiser plus facilement ce système avec des cases :\n Pour stocker des informations, les bits sont regroupés par paquets appelés “multiplets”. Le plus utilisé est le multiplet de 8 bits : l’octet. Sur l’image ci-dessus, on voit l’octet 00000000. Chaque case correspond à une valeur décimale qui correspond à une dizaine supplémentaire en binaire. Pour écrire le nombre 20, la seule manière de l’écrire ici est 16+4, donc “0-0-0-1-0-1-0-0” =&gt; 00010100\nLe code machine fonctionne ainsi : on sait qu’il fonctionne toujours par un opcode, qui indique ce qui le suivra (un opcode ou une valeur), et chaque groupe de 8 bits compose une brique d’information. &gt; Exemple : le code 01101010 00010100 correspond à l’opcode PUSH (garder une valeur en mémoire), suivi de la valeur 20.\nSe pose alors une dernière question : comment un opcode peut indiquer à un circuit électrique ce qu’il doit faire des informations données ?"
  },
  {
    "objectID": "M2/intro_m2.html#la-bioinformatique-pourquoi-faire",
    "href": "M2/intro_m2.html#la-bioinformatique-pourquoi-faire",
    "title": "Cours M2",
    "section": "",
    "text": "La biologie est une discipline qui étudie des sujets complexes : les être vivants. Cette complexité est due aux très nombreuses interactions entre les “briques” qui composent les être vivants, à différentes échelles : les interactions chimiques entre les atomes, les molécules, les protéines, les cellules, les tissus, les organes et même entre les individus. Ainsi, il est difficile d’étudier l’effet d’une protéine sans comprendre ses interactions avec le reste de l’organisme, il faut donc prendre en compte tout l’environnement autour du sujet d’étude pour bien le comprendre. \nLe problème, c’est que lorsque l’on étudie un brin d’ADN, il est difficile de retenir les noms et les interactions des 3.000.000.000.000 paires de bases de l’ADN humain, surtout avec un papier et un crayon. \nL’informatique est alors apparue comme une solution, dans un premier temps de stockage et de requêtage, puis de calcul, et aujourd’hui de prédiction."
  },
  {
    "objectID": "M2/intro_m2.html#programmer-cest-quoi",
    "href": "M2/intro_m2.html#programmer-cest-quoi",
    "title": "Cours M2",
    "section": "",
    "text": "La programmation, c’est donner des instructions à un ordinateur, comme on donnerait des instructions à une calculatrice pour faire un calcul. \nOn parle de langages de programmation car les instructions que l’on utilise sont proches du langage naturel. Par exemple, on comprendra facilement que la commande “cos(5)” indique d’effectuer le calcul “cosinus de 5”."
  },
  {
    "objectID": "M2/intro_m2.html#un-peu-dhistoire",
    "href": "M2/intro_m2.html#un-peu-dhistoire",
    "title": "Cours M2",
    "section": "",
    "text": "Les premières années de l’informatique remontent vers 1890, lorsque Herman Hollerith (futur fondateur d’IBM) dépose un brevet pour une machine à calculer en se basant sur les travaux de Charles Babbage et Ada Lovelace (1842). L’objectif était d’aider au recensement des Etats-unis en automatisant les calculs, car à cette époque le recensement était réalisé tous les dix ans et nécessitait neuf ans de travail.\nLes machines à calculer, appelés tabulatrices étaient électro-mécaniques et disposaient de programmes “fixes” : la machine contenait un panneau de contrôle, dans lequel le fabriquant avait “écrit” les instructions en suivant un schéma de câblage. Une machine à calculer était grosse comme un bureau et ne pouvait exécuter qu’un seul programme. Les données étaient saisies sur des cartes perforées et lues en direct par la machine. La carte perforée était lue via des aiguilles qui passaient (ou non) au travers des perforations, puis atterissaient dans un bain de mercure pour fermer un circuit électrique.\n\n\n\n\n\n\n\n\n\nCarte perforée, inspirée des tickets de trains poinçonnés en fonction de l’âge et du sexe des voyageurs\n\n\n\n\n\n\n\nTabulatrice IBM 401, 1948\n\n\n\n\n\nPar la suite, des panneaux de contrôle amovibles sont apparus : pour changer de programme informatique, on changeait le panneau de contrôle. \n\n\n\n\n\n\n\n\n\nPanneau de contrôle d’une tabulatrice\n\n\n\n\n\n\n\nPanneau de contrôle d’une tabulatrice câblé\n\n\n\n\n\n\n\nSchéma du panneau de contrôle d’une tabulatrice\n\n\n\n\n\nDans les années 1960, l’arrivée des transistors permet le début des sytèmes 100% électriques, on change alors de paradigme : un processeur unique permet de faire tous les calculs, et l’utilisateur définit le programme. Cependant, les ordinateurs ne disposent pas encore de mémoire pour se souvenir des différentes étapes d’un programme, le code était alors lui aussi écrit sur des cartes perforées. \n\n\n\nCarte perforée contenant la ligne d’instruction “IF MOD-G-JAHR NOT NUMERIC MOVE ZERO TO MOD-G-JAHR”, écrite en COBOL, 1959\n\n\nLa question que l’on se pose alors est “Comment ces instructions, sous forme de lettres, permettent à des circuits électriques de faire des calculs ?” \nPour comprendre cela, il faut d’abord expliquer comment les commandes d’un langage de programmation sont lues par l’ordinateur.\nPrenons la commande R suivante : print(“Hello World!”) Lorsque l’on va demander à l’ordinateur d’exécuter cette ligne, il va d’abord la traduire en code machine, composé de 0 et de 1 : c’est la compilation. Le code machine est illisible pour les humains, mais est en fait la traduction du code en Assembleur : un langage partagé par tous les processeurs, et qui décompose chaque fonction en une suite d’instructions basiques. &gt; Cette explication est très simplifiée, mais il serait trop complexe de tout détailler ici\n\n\n\n\n\n\nLes bits\n\n\n\nCe que l’on appelle “0 et 1” sont des bits : la plus petite unité d’information possible. Dans un circuit électrique 1 = du courant électrique qui passe, 0 = un courant très faible\n\n\n\n\n\n\n\n\n\n\n\nUne commande écrite en R, s’exécutant en 39 microsecondes (0.000039 s)\n\n\n\n\n\n\n\nLe même code, en assembleur\n\n\n\n\n\n\n\nLe même code, en langage machine\n\n\n\n\n\nMOV, RAX ou RDI sont des “opcodes” (Operation Code) : ce sont des instructions très simples, envoyées au processeur. Un peu à la manière des codons dans l’ADN, ils indiquent ce qui vient après eux. Par exemple, un codon d’initiation dans l’ADN indique le début d’une séquence codante et initialise la traduction de ce qui vient après, jusqu’à rencontrer un codon STOP. Ici, l’opcode MOV sera toujours suivi d’un autre opcode, et RAX est toujours suivi d’une valeur : c’est comme cela qu’on peut traduire des instructions en une suite de 0 et 1\n\n\n\nTraduction de l’ADN à partir du codon d’initation AUG\n\n\n\nLes OPCODES sont comme des codons : ils indiquent une action. 0 et 1 sont comme les nucléotides Tout comme les nucléotides sont regroupés par 3 pour former des acides aminés, les bits (0 et 1) se rassemblent par groupes (souvent de 8) pour former des octets.\n\n\n\nPour bien comprendre comment des instructions comme “MOV”,“RAX” ou des valeurs comme 20 ou 60 sont transformées et lues sous formes de bits, il faut comprendre le système binaire. \nAu quotidien, on utilise le système décimal : 10 chiffres (0 à 9), puis on passe à une dizaine (10). Le système binaire fonctionne de la même manière, mais n’utilise que 1 et 0. Ainsi, pour compter 0,1,2,3,4,5 en binaire cela donne 0,1,10,11,100,101. On peut visualiser plus facilement ce système avec des cases :\n Pour stocker des informations, les bits sont regroupés par paquets appelés “multiplets”. Le plus utilisé est le multiplet de 8 bits : l’octet. Sur l’image ci-dessus, on voit l’octet 00000000. Chaque case correspond à une valeur décimale qui correspond à une dizaine supplémentaire en binaire. Pour écrire le nombre 20, la seule manière de l’écrire ici est 16+4, donc “0-0-0-1-0-1-0-0” =&gt; 00010100\nLe code machine fonctionne ainsi : on sait qu’il fonctionne toujours par un opcode, qui indique ce qui le suivra (un opcode ou une valeur), et chaque groupe de 8 bits compose une brique d’information. &gt; Exemple : le code 01101010 00010100 correspond à l’opcode PUSH (garder une valeur en mémoire), suivi de la valeur 20.\nSe pose alors une dernière question : comment un opcode peut indiquer à un circuit électrique ce qu’il doit faire des informations données ?"
  },
  {
    "objectID": "L2/intro_l2.html",
    "href": "L2/intro_l2.html",
    "title": "Cours L2",
    "section": "",
    "text": "La biologie est une discipline qui étudie des sujets complexes : les être vivants. Cette complexité est due aux très nombreuses interactions entre les “briques” qui composent les être vivants, à différentes échelles : les interactions chimiques entre les atomes, les molécules, les protéines, les cellules, les tissus, les organes et même entre les individus. Ainsi, il est difficile d’étudier l’effet d’une protéine sans comprendre ses interactions avec le reste de l’organisme, il faut donc prendre en compte tout l’environnement autour du sujet d’étude pour bien le comprendre. \nLe problème, c’est que lorsque l’on étudie un brin d’ADN, il est difficile de retenir les noms et les interactions des 3.000.000.000.000 paires de bases de l’ADN humain, surtout avec un papier et un crayon. \nL’informatique est alors apparue comme une solution, dans un premier temps de stockage et de requêtage, puis de calcul, et aujourd’hui de prédiction.\n\n\n\n\n\nLa programmation, c’est donner des instructions à un ordinateur, comme on donnerait des instructions à une calculatrice pour faire un calcul. \nOn parle de langages de programmation car les instructions que l’on utilise sont proches du langage naturel. Par exemple, on comprendra facilement que la commande “cos(5)” indique d’effectuer le calcul “cosinus de 5”. \n\n\n\nLes premières années de l’informatique remontent vers 1890, lorsque Herman Hollerith (futur fondateur d’IBM) dépose un brevet pour une machine à calculer en se basant sur les travaux de Charles Babbage et Ada Lovelace (1842). L’objectif était d’aider au recensement des Etats-unis en automatisant les calculs, car à cette époque le recensement était réalisé tous les dix ans et nécessitait neuf ans de travail.\nLes machines à calculer, appelés tabulatrices étaient électro-mécaniques et disposaient de programmes “fixes” : la machine contenait un panneau de contrôle, dans lequel le fabriquant avait “écrit” les instructions en suivant un schéma de câblage. Une machine à calculer était grosse comme un bureau et ne pouvait exécuter qu’un seul programme. Les données étaient saisies sur des cartes perforées et lues en direct par la machine. La carte perforée était lue via des aiguilles qui passaient (ou non) au travers des perforations, puis atterissaient dans un bain de mercure pour fermer un circuit électrique.\n\n\n\n\n\n\n\n\n\nCarte perforée, inspirée des tickets de trains poinçonnés en fonction de l’âge et du sexe des voyageurs\n\n\n\n\n\n\n\nTabulatrice IBM 401, 1948\n\n\n\n\n\nPar la suite, des panneaux de contrôle amovibles sont apparus : pour changer de programme informatique, on changeait le panneau de contrôle. \n\n\n\n\n\n\n\n\n\nPanneau de contrôle d’une tabulatrice\n\n\n\n\n\n\n\nPanneau de contrôle d’une tabulatrice câblé\n\n\n\n\n\n\n\nSchéma du panneau de contrôle d’une tabulatrice\n\n\n\n\n\nDans les années 1960, l’arrivée des transistors permet le début des sytèmes 100% électriques, on change alors de paradigme : un processeur unique permet de faire tous les calculs, et l’utilisateur définit le programme. Cependant, les ordinateurs ne disposent pas encore de mémoire pour se souvenir des différentes étapes d’un programme, le code était alors lui aussi écrit sur des cartes perforées. \n\n\n\nCarte perforée contenant la ligne d’instruction “IF MOD-G-JAHR NOT NUMERIC MOVE ZERO TO MOD-G-JAHR”, écrite en COBOL, 1959\n\n\nLa question que l’on se pose alors est “Comment ces instructions, sous forme de lettres, permettent à des circuits électriques de faire des calculs ?” \nPour comprendre cela, il faut d’abord expliquer comment les commandes d’un langage de programmation sont lues par l’ordinateur.\nPrenons la commande R suivante : print(“Hello World!”) Lorsque l’on va demander à l’ordinateur d’exécuter cette ligne, il va d’abord la traduire en code machine, composé de 0 et de 1 : c’est la compilation. Le code machine est illisible pour les humains, mais est en fait la traduction du code en Assembleur : un langage partagé par tous les processeurs, et qui décompose chaque fonction en une suite d’instructions basiques. &gt; Cette explication est très simplifiée, mais il serait trop complexe de tout détailler ici\n\n\n\n\n\n\nLes bits\n\n\n\nCe que l’on appelle “0 et 1” sont des bits : la plus petite unité d’information possible. Dans un circuit électrique 1 = du courant électrique qui passe, 0 = un courant très faible\n\n\n\n\n\n\n\n\n\n\n\nUne commande écrite en R, s’exécutant en 39 microsecondes (0.000039 s)\n\n\n\n\n\n\n\nLe même code, en assembleur\n\n\n\n\n\n\n\nLe même code, en langage machine\n\n\n\n\n\nMOV, RAX ou RDI sont des “opcodes” (Operation Code) : ce sont des instructions très simples, envoyées au processeur. Un peu à la manière des codons dans l’ADN, ils indiquent ce qui vient après eux. Par exemple, un codon d’initiation dans l’ADN indique le début d’une séquence codante et initialise la traduction de ce qui vient après, jusqu’à rencontrer un codon STOP. Ici, l’opcode MOV sera toujours suivi d’un autre opcode, et RAX est toujours suivi d’une valeur : c’est comme cela qu’on peut traduire des instructions en une suite de 0 et 1\n\n\n\nTraduction de l’ADN à partir du codon d’initation AUG\n\n\n\nLes OPCODES sont comme des codons : ils indiquent une action. 0 et 1 sont comme les nucléotides Tout comme les nucléotides sont regroupés par 3 pour former des acides aminés, les bits (0 et 1) se rassemblent par groupes (souvent de 8) pour former des octets.\n\n\n\nPour bien comprendre comment des instructions comme “MOV”,“RAX” ou des valeurs comme 20 ou 60 sont transformées et lues sous formes de bits, il faut comprendre le système binaire. \nAu quotidien, on utilise le système décimal : 10 chiffres (0 à 9), puis on passe à une dizaine (10). Le système binaire fonctionne de la même manière, mais n’utilise que 1 et 0. Ainsi, pour compter 0,1,2,3,4,5 en binaire cela donne 0,1,10,11,100,101. On peut visualiser plus facilement ce système avec des cases :\n Pour stocker des informations, les bits sont regroupés par paquets appelés “multiplets”. Le plus utilisé est le multiplet de 8 bits : l’octet. Sur l’image ci-dessus, on voit l’octet 00000000. Chaque case correspond à une valeur décimale qui correspond à une dizaine supplémentaire en binaire. Pour écrire le nombre 20, la seule manière de l’écrire ici est 16+4, donc “0-0-0-1-0-1-0-0” =&gt; 00010100\nLe code machine fonctionne ainsi : on sait qu’il fonctionne toujours par un opcode, qui indique ce qui le suivra (un opcode ou une valeur), et chaque groupe de 8 bits compose une brique d’information. &gt; Exemple : le code 01101010 00010100 correspond à l’opcode PUSH (garder une valeur en mémoire), suivi de la valeur 20.\nSe pose alors une dernière question : comment un opcode peut indiquer à un circuit électrique ce qu’il doit faire des informations données ?"
  },
  {
    "objectID": "L2/intro_l2.html#la-bioinformatique-pourquoi-faire",
    "href": "L2/intro_l2.html#la-bioinformatique-pourquoi-faire",
    "title": "Cours L2",
    "section": "",
    "text": "La biologie est une discipline qui étudie des sujets complexes : les être vivants. Cette complexité est due aux très nombreuses interactions entre les “briques” qui composent les être vivants, à différentes échelles : les interactions chimiques entre les atomes, les molécules, les protéines, les cellules, les tissus, les organes et même entre les individus. Ainsi, il est difficile d’étudier l’effet d’une protéine sans comprendre ses interactions avec le reste de l’organisme, il faut donc prendre en compte tout l’environnement autour du sujet d’étude pour bien le comprendre. \nLe problème, c’est que lorsque l’on étudie un brin d’ADN, il est difficile de retenir les noms et les interactions des 3.000.000.000.000 paires de bases de l’ADN humain, surtout avec un papier et un crayon. \nL’informatique est alors apparue comme une solution, dans un premier temps de stockage et de requêtage, puis de calcul, et aujourd’hui de prédiction."
  },
  {
    "objectID": "L2/intro_l2.html#programmer-cest-quoi",
    "href": "L2/intro_l2.html#programmer-cest-quoi",
    "title": "Cours L2",
    "section": "",
    "text": "La programmation, c’est donner des instructions à un ordinateur, comme on donnerait des instructions à une calculatrice pour faire un calcul. \nOn parle de langages de programmation car les instructions que l’on utilise sont proches du langage naturel. Par exemple, on comprendra facilement que la commande “cos(5)” indique d’effectuer le calcul “cosinus de 5”."
  },
  {
    "objectID": "L2/intro_l2.html#un-peu-dhistoire",
    "href": "L2/intro_l2.html#un-peu-dhistoire",
    "title": "Cours L2",
    "section": "",
    "text": "Les premières années de l’informatique remontent vers 1890, lorsque Herman Hollerith (futur fondateur d’IBM) dépose un brevet pour une machine à calculer en se basant sur les travaux de Charles Babbage et Ada Lovelace (1842). L’objectif était d’aider au recensement des Etats-unis en automatisant les calculs, car à cette époque le recensement était réalisé tous les dix ans et nécessitait neuf ans de travail.\nLes machines à calculer, appelés tabulatrices étaient électro-mécaniques et disposaient de programmes “fixes” : la machine contenait un panneau de contrôle, dans lequel le fabriquant avait “écrit” les instructions en suivant un schéma de câblage. Une machine à calculer était grosse comme un bureau et ne pouvait exécuter qu’un seul programme. Les données étaient saisies sur des cartes perforées et lues en direct par la machine. La carte perforée était lue via des aiguilles qui passaient (ou non) au travers des perforations, puis atterissaient dans un bain de mercure pour fermer un circuit électrique.\n\n\n\n\n\n\n\n\n\nCarte perforée, inspirée des tickets de trains poinçonnés en fonction de l’âge et du sexe des voyageurs\n\n\n\n\n\n\n\nTabulatrice IBM 401, 1948\n\n\n\n\n\nPar la suite, des panneaux de contrôle amovibles sont apparus : pour changer de programme informatique, on changeait le panneau de contrôle. \n\n\n\n\n\n\n\n\n\nPanneau de contrôle d’une tabulatrice\n\n\n\n\n\n\n\nPanneau de contrôle d’une tabulatrice câblé\n\n\n\n\n\n\n\nSchéma du panneau de contrôle d’une tabulatrice\n\n\n\n\n\nDans les années 1960, l’arrivée des transistors permet le début des sytèmes 100% électriques, on change alors de paradigme : un processeur unique permet de faire tous les calculs, et l’utilisateur définit le programme. Cependant, les ordinateurs ne disposent pas encore de mémoire pour se souvenir des différentes étapes d’un programme, le code était alors lui aussi écrit sur des cartes perforées. \n\n\n\nCarte perforée contenant la ligne d’instruction “IF MOD-G-JAHR NOT NUMERIC MOVE ZERO TO MOD-G-JAHR”, écrite en COBOL, 1959\n\n\nLa question que l’on se pose alors est “Comment ces instructions, sous forme de lettres, permettent à des circuits électriques de faire des calculs ?” \nPour comprendre cela, il faut d’abord expliquer comment les commandes d’un langage de programmation sont lues par l’ordinateur.\nPrenons la commande R suivante : print(“Hello World!”) Lorsque l’on va demander à l’ordinateur d’exécuter cette ligne, il va d’abord la traduire en code machine, composé de 0 et de 1 : c’est la compilation. Le code machine est illisible pour les humains, mais est en fait la traduction du code en Assembleur : un langage partagé par tous les processeurs, et qui décompose chaque fonction en une suite d’instructions basiques. &gt; Cette explication est très simplifiée, mais il serait trop complexe de tout détailler ici\n\n\n\n\n\n\nLes bits\n\n\n\nCe que l’on appelle “0 et 1” sont des bits : la plus petite unité d’information possible. Dans un circuit électrique 1 = du courant électrique qui passe, 0 = un courant très faible\n\n\n\n\n\n\n\n\n\n\n\nUne commande écrite en R, s’exécutant en 39 microsecondes (0.000039 s)\n\n\n\n\n\n\n\nLe même code, en assembleur\n\n\n\n\n\n\n\nLe même code, en langage machine\n\n\n\n\n\nMOV, RAX ou RDI sont des “opcodes” (Operation Code) : ce sont des instructions très simples, envoyées au processeur. Un peu à la manière des codons dans l’ADN, ils indiquent ce qui vient après eux. Par exemple, un codon d’initiation dans l’ADN indique le début d’une séquence codante et initialise la traduction de ce qui vient après, jusqu’à rencontrer un codon STOP. Ici, l’opcode MOV sera toujours suivi d’un autre opcode, et RAX est toujours suivi d’une valeur : c’est comme cela qu’on peut traduire des instructions en une suite de 0 et 1\n\n\n\nTraduction de l’ADN à partir du codon d’initation AUG\n\n\n\nLes OPCODES sont comme des codons : ils indiquent une action. 0 et 1 sont comme les nucléotides Tout comme les nucléotides sont regroupés par 3 pour former des acides aminés, les bits (0 et 1) se rassemblent par groupes (souvent de 8) pour former des octets.\n\n\n\nPour bien comprendre comment des instructions comme “MOV”,“RAX” ou des valeurs comme 20 ou 60 sont transformées et lues sous formes de bits, il faut comprendre le système binaire. \nAu quotidien, on utilise le système décimal : 10 chiffres (0 à 9), puis on passe à une dizaine (10). Le système binaire fonctionne de la même manière, mais n’utilise que 1 et 0. Ainsi, pour compter 0,1,2,3,4,5 en binaire cela donne 0,1,10,11,100,101. On peut visualiser plus facilement ce système avec des cases :\n Pour stocker des informations, les bits sont regroupés par paquets appelés “multiplets”. Le plus utilisé est le multiplet de 8 bits : l’octet. Sur l’image ci-dessus, on voit l’octet 00000000. Chaque case correspond à une valeur décimale qui correspond à une dizaine supplémentaire en binaire. Pour écrire le nombre 20, la seule manière de l’écrire ici est 16+4, donc “0-0-0-1-0-1-0-0” =&gt; 00010100\nLe code machine fonctionne ainsi : on sait qu’il fonctionne toujours par un opcode, qui indique ce qui le suivra (un opcode ou une valeur), et chaque groupe de 8 bits compose une brique d’information. &gt; Exemple : le code 01101010 00010100 correspond à l’opcode PUSH (garder une valeur en mémoire), suivi de la valeur 20.\nSe pose alors une dernière question : comment un opcode peut indiquer à un circuit électrique ce qu’il doit faire des informations données ?"
  },
  {
    "objectID": "L2/presentation_1.html",
    "href": "L2/presentation_1.html",
    "title": "presentation R",
    "section": "",
    "text": "Left column\n\nRight column\n\n\n\nNotes du présentateur"
  },
  {
    "objectID": "L2/presentation_1.html#la-bioinformatique-pourquoi-faire",
    "href": "L2/presentation_1.html#la-bioinformatique-pourquoi-faire",
    "title": "presentation R",
    "section": "",
    "text": "Left column\n\nRight column\n\n\n\nNotes du présentateur"
  },
  {
    "objectID": "L2/presentation_1.html#un-peu-dhistoire",
    "href": "L2/presentation_1.html#un-peu-dhistoire",
    "title": "presentation R",
    "section": "Un peu d’histoire",
    "text": "Un peu d’histoire\n\n\n\n\n\n\n\n\n\nCarte perforée, inspirée des tickets de trains poinçonnés en fonction de l’âge et du sexe des voyageurs\n\n\n\n\n\n\n\nTabulatrice IBM 401, 1948"
  },
  {
    "objectID": "presentations/presentation_1.html",
    "href": "presentations/presentation_1.html",
    "title": "Introduction à R  et à la gestion de données",
    "section": "",
    "text": "La biologie : une discipline complexe\n\nNombreuses interactions moléculaires, cellulaires, tissulaires, organiques\nBesoin d’étudier un sujet dans son contexte\nDes outils qui permettent de collecter de très nombreuses données\n\n\n\n\nL’informatique : une solution puissante\n\nPossibilité de traiter des milliards de données avec un ordinateur portable\nDes outils de plus en plus user-friendly\nUne communauté orientée Open Source et partage\n\n\n\n\n\n\nADN humain : 3 milliards de paires de bases\nMédicaments : ex vivo -&gt; in vivo\nBruler une boite de pétri ne guérit pas le cancer\nMémoire vive : pas un problème pour traiter des données\nOpen Source = public, souvent gratuit\nDe nombreux livres/tutos gratuits en ligne"
  },
  {
    "objectID": "presentations/presentation_1.html#la-bioinformatique-pourquoi-faire",
    "href": "presentations/presentation_1.html#la-bioinformatique-pourquoi-faire",
    "title": "Introduction à R  et à la gestion de données",
    "section": "",
    "text": "La biologie : une discipline complexe\n\nNombreuses interactions moléculaires, cellulaires, tissulaires, organiques\nBesoin d’étudier un sujet dans son contexte\nDes outils qui permettent de collecter de très nombreuses données\n\n\n\n\nL’informatique : une solution puissante\n\nPossibilité de traiter des milliards de données avec un ordinateur portable\nDes outils de plus en plus user-friendly\nUne communauté orientée Open Source et partage\n\n\n\n\n\n\nADN humain : 3 milliards de paires de bases\nMédicaments : ex vivo -&gt; in vivo\nBruler une boite de pétri ne guérit pas le cancer\nMémoire vive : pas un problème pour traiter des données\nOpen Source = public, souvent gratuit\nDe nombreux livres/tutos gratuits en ligne"
  },
  {
    "objectID": "presentations/presentation_1.html#un-peu-dhistoire",
    "href": "presentations/presentation_1.html#un-peu-dhistoire",
    "title": "Introduction à R  et à la gestion de données",
    "section": "Un peu d’histoire",
    "text": "Un peu d’histoire"
  },
  {
    "objectID": "pages/debuter-r.html",
    "href": "pages/debuter-r.html",
    "title": "Débuter R",
    "section": "",
    "text": "Pour programmer en R, on utilise généralement un Environnement de développement, ou IDE, un logiciel qui permet d’écrire du code R et de l’exéctuer, comme RStudio. \n\n\n\nCapture d’écran de RStudio\n\n\n\nL’écran de RStudio est découpé en quatre parties\n\nEn haut à gauche : le script (l’entièreté du code, que l’on pourra enregistrer pour le réutiliser)\nEn haut à droite : l’environnement (indique les données enregistrées)\nEn bas à gauche : la console (exécute le code)\nEn bas à droite : le Viewer : permet de visualiser le résultat du code\n\n\nPour ce cours, vous utiliserez les blocs de code interactifs du document. Grâce à un outil appelé WebR, le code R est traduit en WebAssembly, un langage utilisé par les navigateurs Web.\n\nprint(\"Hello World!\")\n\n\nfor(i in 1:10){\n  print(i)\n}\n\n\n#| edit: false # Empêche les utilisateurs de modifier le bloc de code\n#| caption: Immediate Execution # nom affiché du bloc de code\n#| autorun: true # exécute automatiquement le code au lancement de la page\n#| runbutton: false # désactive le bouton qui permet d'exécuter le code\n#| completion: true # autorise l'autocomplétion du code\n#| include: false # equivalent de echo=FALSE/output=FALSE\n#| startover: false # supprimer le bouton \"startover\"\n#| persist: true #le code (et résultat) sera sauvegardé en local dans le navigateur. Les objets resteront quand la page HTML sera rechargée\n#| timelimit: 3 # En secondes, le temps max d'exécution. Si dépassé, renvoie une erreur. Par défaut, 30. Si 0, infini\n#| min-lines: 6  # taille minimale du bloc de code\n#| max-lines: 10 # taille max du bloc de code, si dépasse, passe en scrolling\n\n\nfor(i in 1:10){\n  print(i)\n}\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: note, warning, important, tip, and caution.\n\n\n\n\n\n\n\n\nAstuce\n\n\n\nThis is an example of a callout with a title.\n\n\n\n\n\n\n\n\nExpand To Learn About Collapse\n\n\n\n\n\nThis is an example of a ‘folded’ caution callout that can be expanded by the user. You can use collapse=\"true\" to collapse it by default or collapse=\"false\" to make a collapsible callout that is expanded by default.",
    "crumbs": [
      "Débuter R"
    ]
  },
  {
    "objectID": "index.html#le-binaire",
    "href": "index.html#le-binaire",
    "title": "Introduction",
    "section": "Le binaire",
    "text": "Le binaire\nPour bien comprendre comment des instructions comme “MOV”,“RAX” ou des valeurs comme 20 ou 60 sont transformées et lues sous formes de bits, il faut comprendre le système binaire. \nAu quotidien, on utilise le système décimal : 10 chiffres (0 à 9), puis on passe à une dizaine (10). Le système binaire fonctionne de la même manière, mais n’utilise que 1 et 0. Ainsi, pour compter 0,1,2,3,4,5 en binaire cela donne 0,1,10,11,100,101. On peut visualiser plus facilement ce système avec des cases :\n\n\n\nDémonstration pour un nombre encodé en 8 bits\n\n\nPour stocker des informations, les bits sont regroupés par paquets appelés “multiplets”. Le plus utilisé est le multiplet de 8 bits : l’octet. Sur l’image ci-dessus, on voit l’octet 00000000. Chaque case correspond à une valeur décimale qui correspond à une dizaine supplémentaire en binaire. Pour écrire le nombre 20, la seule manière de l’écrire ici est 16+4, donc “0-0-0-1-0-1-0-0” =&gt; 00010100\nLe code machine fonctionne ainsi : on sait qu’il fonctionne toujours par un opcode, qui indique ce qui le suivra (un opcode ou une valeur), et chaque groupe de 8 bits compose une brique d’information. &gt; Exemple : le code 01101010 00010100 correspond à l’opcode PUSH (garder une valeur en mémoire), suivi de la valeur 20.\nSe pose alors une dernière question : comment un opcode peut indiquer à un circuit électrique ce qu’il doit faire des informations données ?",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#les-transistors-et-portes-logiques",
    "href": "index.html#les-transistors-et-portes-logiques",
    "title": "Introduction",
    "section": "Les transistors et portes logiques",
    "text": "Les transistors et portes logiques\n\n\n\nDe gauche à droite : un transistor seul, un montage “AND”, un montage “OR”\n\n\nUn transistor permet d’ouvrir ou fermer un circuit électrique : si on lui envoie un fort courant, il le laisse passer, si c’est un courant faible, il bloque l’arrivée. Pour définir les courants entrants et sortants, on parle d’inputs et d’outputs : 1 lorsque le courant passe, 0 lorsqu’il ne passe pas.\nL’intérêt du transistor arrive lorsqu’il est combiné : il est possible de créer différents types de “portes” :\n\nAND : renvoie 1 si les inputs sont 1-1\nOR : renvoie 1 si au moins l’un des deux inputs contient 1 (“l’un ou l’autre”)\nXOR : renvoie 1 si les inputs sont 1-0 ou 0-1 (“Soit l’un, soit l’autre” = ou exclusif)\nNOT : renvoie 1 si les inputs sont 0-0\nNAND : renvoie 1 si les inputs ne sont pas 1-1\n\n\n\n\nUne porte XOR\n\n\nCes montages simples permettent d’effectuer des opérations complexes lorsqu’on les combine à nouveau :\n\n\n\nUn montage permettant de réaliser une addition\n\n\n\nEssayez d’expliquer le fonctionnement de ce montage\n\n\n\n\n\n\n\n\n\n\nUn montage “Full adder” 4 bits\n\n\n\n\n\n\n\nSchéma d’un full adder 4 bits\n\n\n\n\n\n\nUn “Full adder” est un montage permettant d’effectuer une addition de deux nombres composés de 4 bits (de 0 à 8). La retenue valant 8, on peut calculer jusqu’à 8+8=16.\n\nIl existe différents montages de ce type pour effectuer les calculs de base d’un ordinateur : les adder, substracter, incrementer, decrementer, etc…\n\nLes processeurs les plus récents mesurent environ 4x4cm et contient plus de 40 milliards de transistors, d’environ 7nm (70 atomes), avec une fréquence de 5GHz. Les ordinateurs actuels fonctionnent avec des architectures en 64 bits.\n\nLorsque du code est exécuté sur un ordinateur, il est d’abord traduit en assembleur. Le code assembleur est lisible par les humains, et est l’équivalent du code binaire qui sera lu par la machine (C’est le code machine)\n\n\n\n\n\n\n \n\n\n\nDans le code binaire, les 4 premiers chiffres correspondent à l’opcode : l’action à effectuer. Les deux premiers indiquent le type d’opération (charger une valeur, la stocker, faire une opération arithmétique), et les deux suivants indiquent laquelle.\n\nExemple : 00 = arithmétique, 00 01 = soustraction\n\n\n\n\nMontage d’un Binary Decoder : chaque combinaison renvoie vers une sortie différente\n\n\nUn Binary Decoder est un aiguilleur qui renvoie les informations vers les différents montages. Ici, le 01 correspond à l’opération “soustraction”, et renvoie vers la 2e sortie.\n\n\n\nLe 2e output : un 8bit substracter",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#tabulatrices",
    "href": "index.html#tabulatrices",
    "title": "Introduction",
    "section": "Tabulatrices",
    "text": "Tabulatrices\nPage wikipédia : En français - En anglais\nUniversité Columbia : - Panneaux de controles des tabulatrices",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#transistors",
    "href": "index.html#transistors",
    "title": "Introduction",
    "section": "Transistors",
    "text": "Transistors\nSite du lycée Saint François-Xavier Fonctionnement des transistors\nVidéo YouTube : How transistors run code ?\nVidéo YouTube : La traduction de l’ADNm en protéines",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#cartes-perforées",
    "href": "index.html#cartes-perforées",
    "title": "Introduction",
    "section": "Cartes perforées",
    "text": "Cartes perforées\nPage wikipédia : En français - En anglais",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "presentations/presentation_1.html#slide-2",
    "href": "presentations/presentation_1.html#slide-2",
    "title": "Introduction à R  et à la gestion de données",
    "section": "Slide 2",
    "text": "Slide 2\n\nNotes du présentateur"
  },
  {
    "objectID": "presentations/presentation_1.html#la-bio-informatique-pourquoi-faire",
    "href": "presentations/presentation_1.html#la-bio-informatique-pourquoi-faire",
    "title": "Introduction à R et à la gestion de données",
    "section": "La Bio-Informatique, pourquoi faire ?",
    "text": "La Bio-Informatique, pourquoi faire ?\n\n\nLa biologie : une discipline complexe\n\nNombreuses interactions moléculaires, cellulaires, tissulaires, organiques\nBesoin d’étudier un sujet dans son contexte\nDes outils qui permettent de collecter de très nombreuses données\n\nL’informatique : une solution puissante\n\nPossibilité de traiter des milliards de données avec un ordinateur portable\nDes outils de plus en plus user-friendly\nUne communauté orientée Open Source et partage\n\n\n\n\n\nADN humain : 3 milliards de paires de bases\nMédicaments : ex vivo -&gt; in vivo\nMémoire vive : pas un problème pour traiter des données\nOpen Source = public, souvent gratuit\nDe nombreux livres/tutos gratuits en ligne"
  },
  {
    "objectID": "presentations/presentation_1.html#r-cest-quoi",
    "href": "presentations/presentation_1.html#r-cest-quoi",
    "title": "Introduction à R  et à la gestion de données",
    "section": "R, c’est quoi ?",
    "text": "R, c’est quoi ?\nR est un langage de programmation dédié à l’analyse et la visualisation de données Il permet de :\n\nDonner des instructions à l’ordinateur\nTraiter de grands volumes de données\nGénérer des graphes, des rapports et des applications\n\n\nOn parle de langage de programmation car les instructions sont données sous forme de langage : des verbes, des objets et une grammaire pour lier le tout"
  },
  {
    "objectID": "presentations/presentation_1.html#quelques-exemples-iris",
    "href": "presentations/presentation_1.html#quelques-exemples-iris",
    "title": "Introduction à R  et à la gestion de données",
    "section": "Quelques exemples : iris",
    "text": "Quelques exemples : iris\n\nDataAnalyse\n\n\n\niris\n\n    Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n1            5.1         3.5          1.4         0.2     setosa\n2            4.9         3.0          1.4         0.2     setosa\n3            4.7         3.2          1.3         0.2     setosa\n4            4.6         3.1          1.5         0.2     setosa\n5            5.0         3.6          1.4         0.2     setosa\n6            5.4         3.9          1.7         0.4     setosa\n7            4.6         3.4          1.4         0.3     setosa\n8            5.0         3.4          1.5         0.2     setosa\n9            4.4         2.9          1.4         0.2     setosa\n10           4.9         3.1          1.5         0.1     setosa\n11           5.4         3.7          1.5         0.2     setosa\n12           4.8         3.4          1.6         0.2     setosa\n13           4.8         3.0          1.4         0.1     setosa\n14           4.3         3.0          1.1         0.1     setosa\n15           5.8         4.0          1.2         0.2     setosa\n16           5.7         4.4          1.5         0.4     setosa\n17           5.4         3.9          1.3         0.4     setosa\n18           5.1         3.5          1.4         0.3     setosa\n19           5.7         3.8          1.7         0.3     setosa\n20           5.1         3.8          1.5         0.3     setosa\n21           5.4         3.4          1.7         0.2     setosa\n22           5.1         3.7          1.5         0.4     setosa\n23           4.6         3.6          1.0         0.2     setosa\n24           5.1         3.3          1.7         0.5     setosa\n25           4.8         3.4          1.9         0.2     setosa\n26           5.0         3.0          1.6         0.2     setosa\n27           5.0         3.4          1.6         0.4     setosa\n28           5.2         3.5          1.5         0.2     setosa\n29           5.2         3.4          1.4         0.2     setosa\n30           4.7         3.2          1.6         0.2     setosa\n31           4.8         3.1          1.6         0.2     setosa\n32           5.4         3.4          1.5         0.4     setosa\n33           5.2         4.1          1.5         0.1     setosa\n34           5.5         4.2          1.4         0.2     setosa\n35           4.9         3.1          1.5         0.2     setosa\n36           5.0         3.2          1.2         0.2     setosa\n37           5.5         3.5          1.3         0.2     setosa\n38           4.9         3.6          1.4         0.1     setosa\n39           4.4         3.0          1.3         0.2     setosa\n40           5.1         3.4          1.5         0.2     setosa\n41           5.0         3.5          1.3         0.3     setosa\n42           4.5         2.3          1.3         0.3     setosa\n43           4.4         3.2          1.3         0.2     setosa\n44           5.0         3.5          1.6         0.6     setosa\n45           5.1         3.8          1.9         0.4     setosa\n46           4.8         3.0          1.4         0.3     setosa\n47           5.1         3.8          1.6         0.2     setosa\n48           4.6         3.2          1.4         0.2     setosa\n49           5.3         3.7          1.5         0.2     setosa\n50           5.0         3.3          1.4         0.2     setosa\n51           7.0         3.2          4.7         1.4 versicolor\n52           6.4         3.2          4.5         1.5 versicolor\n53           6.9         3.1          4.9         1.5 versicolor\n54           5.5         2.3          4.0         1.3 versicolor\n55           6.5         2.8          4.6         1.5 versicolor\n56           5.7         2.8          4.5         1.3 versicolor\n57           6.3         3.3          4.7         1.6 versicolor\n58           4.9         2.4          3.3         1.0 versicolor\n59           6.6         2.9          4.6         1.3 versicolor\n60           5.2         2.7          3.9         1.4 versicolor\n61           5.0         2.0          3.5         1.0 versicolor\n62           5.9         3.0          4.2         1.5 versicolor\n63           6.0         2.2          4.0         1.0 versicolor\n64           6.1         2.9          4.7         1.4 versicolor\n65           5.6         2.9          3.6         1.3 versicolor\n66           6.7         3.1          4.4         1.4 versicolor\n67           5.6         3.0          4.5         1.5 versicolor\n68           5.8         2.7          4.1         1.0 versicolor\n69           6.2         2.2          4.5         1.5 versicolor\n70           5.6         2.5          3.9         1.1 versicolor\n71           5.9         3.2          4.8         1.8 versicolor\n72           6.1         2.8          4.0         1.3 versicolor\n73           6.3         2.5          4.9         1.5 versicolor\n74           6.1         2.8          4.7         1.2 versicolor\n75           6.4         2.9          4.3         1.3 versicolor\n76           6.6         3.0          4.4         1.4 versicolor\n77           6.8         2.8          4.8         1.4 versicolor\n78           6.7         3.0          5.0         1.7 versicolor\n79           6.0         2.9          4.5         1.5 versicolor\n80           5.7         2.6          3.5         1.0 versicolor\n81           5.5         2.4          3.8         1.1 versicolor\n82           5.5         2.4          3.7         1.0 versicolor\n83           5.8         2.7          3.9         1.2 versicolor\n84           6.0         2.7          5.1         1.6 versicolor\n85           5.4         3.0          4.5         1.5 versicolor\n86           6.0         3.4          4.5         1.6 versicolor\n87           6.7         3.1          4.7         1.5 versicolor\n88           6.3         2.3          4.4         1.3 versicolor\n89           5.6         3.0          4.1         1.3 versicolor\n90           5.5         2.5          4.0         1.3 versicolor\n91           5.5         2.6          4.4         1.2 versicolor\n92           6.1         3.0          4.6         1.4 versicolor\n93           5.8         2.6          4.0         1.2 versicolor\n94           5.0         2.3          3.3         1.0 versicolor\n95           5.6         2.7          4.2         1.3 versicolor\n96           5.7         3.0          4.2         1.2 versicolor\n97           5.7         2.9          4.2         1.3 versicolor\n98           6.2         2.9          4.3         1.3 versicolor\n99           5.1         2.5          3.0         1.1 versicolor\n100          5.7         2.8          4.1         1.3 versicolor\n101          6.3         3.3          6.0         2.5  virginica\n102          5.8         2.7          5.1         1.9  virginica\n103          7.1         3.0          5.9         2.1  virginica\n104          6.3         2.9          5.6         1.8  virginica\n105          6.5         3.0          5.8         2.2  virginica\n106          7.6         3.0          6.6         2.1  virginica\n107          4.9         2.5          4.5         1.7  virginica\n108          7.3         2.9          6.3         1.8  virginica\n109          6.7         2.5          5.8         1.8  virginica\n110          7.2         3.6          6.1         2.5  virginica\n111          6.5         3.2          5.1         2.0  virginica\n112          6.4         2.7          5.3         1.9  virginica\n113          6.8         3.0          5.5         2.1  virginica\n114          5.7         2.5          5.0         2.0  virginica\n115          5.8         2.8          5.1         2.4  virginica\n116          6.4         3.2          5.3         2.3  virginica\n117          6.5         3.0          5.5         1.8  virginica\n118          7.7         3.8          6.7         2.2  virginica\n119          7.7         2.6          6.9         2.3  virginica\n120          6.0         2.2          5.0         1.5  virginica\n121          6.9         3.2          5.7         2.3  virginica\n122          5.6         2.8          4.9         2.0  virginica\n123          7.7         2.8          6.7         2.0  virginica\n124          6.3         2.7          4.9         1.8  virginica\n125          6.7         3.3          5.7         2.1  virginica\n126          7.2         3.2          6.0         1.8  virginica\n127          6.2         2.8          4.8         1.8  virginica\n128          6.1         3.0          4.9         1.8  virginica\n129          6.4         2.8          5.6         2.1  virginica\n130          7.2         3.0          5.8         1.6  virginica\n131          7.4         2.8          6.1         1.9  virginica\n132          7.9         3.8          6.4         2.0  virginica\n133          6.4         2.8          5.6         2.2  virginica\n134          6.3         2.8          5.1         1.5  virginica\n135          6.1         2.6          5.6         1.4  virginica\n136          7.7         3.0          6.1         2.3  virginica\n137          6.3         3.4          5.6         2.4  virginica\n138          6.4         3.1          5.5         1.8  virginica\n139          6.0         3.0          4.8         1.8  virginica\n140          6.9         3.1          5.4         2.1  virginica\n141          6.7         3.1          5.6         2.4  virginica\n142          6.9         3.1          5.1         2.3  virginica\n143          5.8         2.7          5.1         1.9  virginica\n144          6.8         3.2          5.9         2.3  virginica\n145          6.7         3.3          5.7         2.5  virginica\n146          6.7         3.0          5.2         2.3  virginica\n147          6.3         2.5          5.0         1.9  virginica\n148          6.5         3.0          5.2         2.0  virginica\n149          6.2         3.4          5.4         2.3  virginica\n150          5.9         3.0          5.1         1.8  virginica\n\n\n\n\n\nsummary(iris)"
  },
  {
    "objectID": "presentations/presentation_1.html#graphes",
    "href": "presentations/presentation_1.html#graphes",
    "title": "Introduction à R  et à la gestion de données",
    "section": "Graphes",
    "text": "Graphes\n\nlibrary(GWalkR)\ngwalkr(iris)"
  },
  {
    "objectID": "presentations/presentation_1.html#les-graphes",
    "href": "presentations/presentation_1.html#les-graphes",
    "title": "Introduction à R  et à la gestion de données",
    "section": "Les graphes",
    "text": "Les graphes\n\nlibrary(ggplot2)\n\nggplot(\n  data = iris,\n  mapping = aes(\n    x = Petal.Length, \n    y = Petal.Width, \n    color = Species\n    )\n  ) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\n\n\nlm = “linear model”, pour régressions linéaires"
  },
  {
    "objectID": "presentations/presentation_1.html#rapports-et-applications",
    "href": "presentations/presentation_1.html#rapports-et-applications",
    "title": "Introduction à R  et à la gestion de données",
    "section": "Rapports et applications",
    "text": "Rapports et applications\n\n\nIndian blood banks\nNew Zealand dashboard\nQuarto HTML Basics\nIntro au Tidyverse"
  },
  {
    "objectID": "index.html#quelques-exemples",
    "href": "index.html#quelques-exemples",
    "title": "Introduction",
    "section": "Quelques exemples",
    "text": "Quelques exemples\n\nStatistique descriptive\n\nDataCode",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#les-graphes",
    "href": "index.html#les-graphes",
    "title": "Introduction",
    "section": "Les graphes",
    "text": "Les graphes\n\nCodeGraphe\n\n\n\nlibrary(ggplot2)\n\nggplot(\n  data = iris,\n  mapping = aes(\n    x = Petal.Length, \n    y = Petal.Width, \n    color = Species\n    )\n  ) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\n\n\n\n\n\n`geom_smooth()` using formula = 'y ~ x'",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#rapports-et-applications",
    "href": "index.html#rapports-et-applications",
    "title": "Introduction",
    "section": "Rapports et applications",
    "text": "Rapports et applications\n\nIndian blood banks\nNew Zealand dashboard\nQuarto HTML Basics\nIntro au Tidyverse",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#graphes",
    "href": "index.html#graphes",
    "title": "Introduction",
    "section": "Graphes",
    "text": "Graphes",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#reporting",
    "href": "index.html#reporting",
    "title": "Introduction",
    "section": "Reporting",
    "text": "Reporting\nQuelques exemples de rapports, tableaux de bord et applications réalisables avec R (et d’autres outils comme Shiny et Quarto)\n\nIndian blood banks\nNew Zealand dashboard\nQuarto HTML Basics\nIntro au Tidyverse",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "pages/2_debuter-r.html",
    "href": "pages/2_debuter-r.html",
    "title": "Débuter R",
    "section": "",
    "text": "Pour programmer en R, on utilise généralement un Environnement de développement, ou IDE : un logiciel qui permet d’écrire du code R et de l’exéctuer, comme RStudio. &gt; Il est important de différencier R (le langage) et RStudio (le logiciel) R est un dictionnaire humain-machine, avec lequel on interagit peu en réalité, et RStudio l’outil qui permet d’écrire du code R\n\n\n\nCapture d’écran de RStudio\n\n\n\nL’écran de RStudio est découpé en quatre parties\n\nEn haut à gauche : le script (l’entièreté du code, que l’on pourra enregistrer pour le réutiliser)\nEn haut à droite : l’environnement (indique les données enregistrées)\nEn bas à gauche : la console (exécute le code)\nEn bas à droite : le Viewer : permet de visualiser le résultat du code\n\n\nLa programmation se fait via l’écriture de commandes dans une console. On enregistre un ensemble de commandes dans un script : un fichier texte, écrit dans un IDE. Le script s’enregistre ensuite dans un fichier avec un format spécifique. Un script R donnera par exemple le fichier “mon_script.R” sur l’ordinateur.\nPour le début de ce cours, vous utiliserez les blocs de code interactifs du document. Grâce à un outil appelé WebR, le code R est traduit en WebAssembly, un langage utilisé par les navigateurs Web.",
    "crumbs": [
      "Débuter R"
    ]
  },
  {
    "objectID": "pages/1_histoire.html",
    "href": "pages/1_histoire.html",
    "title": "Histoire de la programmation",
    "section": "",
    "text": "Les premières années de l’informatique remontent vers 1890, lorsque Herman Hollerith (futur fondateur d’IBM) dépose un brevet pour une machine à calculer en se basant sur les travaux de Charles Babbage et Ada Lovelace (1842). L’objectif était d’aider au recensement des Etats-unis en automatisant les calculs, car à cette époque le recensement était réalisé tous les dix ans et nécessitait neuf ans de travail.\nLes machines à calculer, appelés tabulatrices étaient électro-mécaniques et disposaient de programmes “fixes” : la machine contenait un panneau de contrôle, dans lequel le fabriquant avait “écrit” les instructions en suivant un schéma de câblage. Une machine à calculer était grosse comme un bureau et ne pouvait exécuter qu’un seul programme. Les données étaient saisies sur des cartes perforées et lues en direct par la machine. La carte perforée était lue via des aiguilles qui passaient (ou non) au travers des perforations, puis atterissaient dans un bain de mercure pour fermer un circuit électrique.\n\n\n\n\n\n\n\n\n\nCarte perforée, inspirée des tickets de trains poinçonnés en fonction de l’âge et du sexe des voyageurs\n\n\n\n\n\n\n\nTabulatrice IBM 401, 1948\n\n\n\n\n\nPar la suite, des panneaux de contrôle amovibles sont apparus : pour changer de programme informatique, on changeait le panneau de contrôle. \n\n\n\n\n\n\n\n\n\nPanneau de contrôle d’une tabulatrice\n\n\n\n\n\n\n\nPanneau de contrôle d’une tabulatrice câblé\n\n\n\n\n\n\n\nSchéma du panneau de contrôle d’une tabulatrice\n\n\n\n\n\nDans les années 1960, l’arrivée des transistors permet le début des sytèmes 100% électriques, on change alors de paradigme : un processeur unique permet de faire tous les calculs, et l’utilisateur définit le programme. Cependant, les ordinateurs ne disposent pas encore de mémoire pour se souvenir des différentes étapes d’un programme, le code était alors lui aussi écrit sur des cartes perforées. \n\n\n\nCarte perforée contenant la ligne d’instruction “IF MOD-G-JAHR NOT NUMERIC MOVE ZERO TO MOD-G-JAHR”, écrite en COBOL, 1959\n\n\nLes cartes perforées ont été utilisées jusqu’à la fin des années 70, voire même plus tard. L’arrivée des supports de mémoire magnétiques (floppy disks, disquettes, clés USB, etc…) a permit de les remplacer.\nLa question que l’on se pose alors est “Comment ces instructions, sous forme de lettres, permettent à des circuits électriques de faire des calculs ?” \nPour comprendre cela, il faut d’abord expliquer comment les commandes d’un langage de programmation sont lues par l’ordinateur.\nPrenons la commande R suivante : print(“Hello World!”) Lorsque l’on va demander à l’ordinateur d’exécuter cette ligne, il va d’abord la traduire en code machine, composé de 0 et de 1 : c’est la compilation. Le code machine est illisible pour les humains, mais est en fait la traduction du code en Assembleur : un langage partagé par tous les processeurs, et qui décompose chaque fonction en une suite d’instructions basiques. &gt; Cette explication est très simplifiée, mais il serait trop complexe de tout détailler ici\n\n\n\n\n\n\nLes bits\n\n\n\nCe que l’on appelle “0 et 1” sont des bits : la plus petite unité d’information possible. Dans un circuit électrique 1 = du courant électrique qui passe, 0 = un courant très faible\n\n\n\n\n\n\n\n\n\n\n\nUne commande écrite en R, s’exécutant en 39 microsecondes (0.000039 s)\n\n\n\n\n\n\n\nLe même code, en assembleur\n\n\n\n\n\n\n\nLe même code, en langage machine\n\n\n\n\n\nMOV, RAX ou RDI sont des “opcodes” (Operation Code) : ce sont des instructions très simples, envoyées au processeur. Un peu à la manière des codons dans l’ADN, ils indiquent ce qui vient après eux. Par exemple, un codon d’initiation dans l’ADN indique le début d’une séquence codante et initialise la traduction de ce qui vient après, jusqu’à rencontrer un codon STOP. Ici, l’opcode MOV sera toujours suivi d’un autre opcode, et RAX est toujours suivi d’une valeur : c’est comme cela qu’on peut traduire des instructions en une suite de 0 et 1\n\n\n\nTraduction de l’ADN à partir du codon d’initation AUG\n\n\n\nLes OPCODES sont comme des codons : ils indiquent une action. 0 et 1 sont comme les nucléotides Tout comme les nucléotides sont regroupés par 3 pour former des acides aminés, les bits (0 et 1) se rassemblent par groupes (souvent de 8) pour former des octets.",
    "crumbs": [
      "Histoire de la programmation"
    ]
  },
  {
    "objectID": "pages/1_histoire.html#cartes-perforées",
    "href": "pages/1_histoire.html#cartes-perforées",
    "title": "Histoire de la programmation",
    "section": "Cartes perforées",
    "text": "Cartes perforées\nPage wikipédia : En français - En anglais",
    "crumbs": [
      "Histoire de la programmation"
    ]
  },
  {
    "objectID": "pages/1_histoire.html#tabulatrices",
    "href": "pages/1_histoire.html#tabulatrices",
    "title": "Histoire de la programmation",
    "section": "Tabulatrices",
    "text": "Tabulatrices\nPage wikipédia : En français - En anglais\nUniversité Columbia : - Panneaux de controles des tabulatrices",
    "crumbs": [
      "Histoire de la programmation"
    ]
  },
  {
    "objectID": "pages/1_histoire.html#transistors",
    "href": "pages/1_histoire.html#transistors",
    "title": "Histoire de la programmation",
    "section": "Transistors",
    "text": "Transistors\nSite du lycée Saint François-Xavier Fonctionnement des transistors\nVidéo YouTube : How transistors run code ?\nVidéo YouTube : La traduction de l’ADNm en protéines",
    "crumbs": [
      "Histoire de la programmation"
    ]
  },
  {
    "objectID": "pages/3_poo.html",
    "href": "pages/3_poo.html",
    "title": "Les bases",
    "section": "",
    "text": "R est un langage dit à la fois Fonctionnel et Orienté Objet.\nUn script R suit souvent ce schéma :\nLes données sont stockées dans des objets, dont la nature sera déterminée par la classe et qui seront modifiés par des fonctions",
    "crumbs": [
      "Débuter R",
      "Les bases"
    ]
  },
  {
    "objectID": "pages/3_poo.html#les-objets",
    "href": "pages/3_poo.html#les-objets",
    "title": "Les bases",
    "section": "Les objets",
    "text": "Les objets\nUn objet est comme un boîte qui va enregistrer des valeurs, pour ensuite interagir avec. On créé un objet en lui donnant un nom, puis on lui attribue une valeur avec la flèche d’assignation &lt;-\nEn appelant l’objet, on obtient sa valeur\nExemple :\n\n\n\n\n\n\n\n\nUn objet peut contenir plusieurs valeurs, souvent regroupées sous la forme de vecteurs\nUn vecteur est une suite de valeur de même classe (détaillé dans la partie Section 3 ), que l’on créé en regroupant les valeurs avec la fonction c()\n\n\n\n\n\n\n\n\nEn R, certaines fonctions sont dites scalaires : elles s’appliquent sur tout un vecteur et renvoient une seule valeur. A l’inverse, certaines sont dites vectorisées, car elles s’appliquent sur toutes les valeurs d’un vecteur. Les fonctions vectorisées qui combinent un vecteur avec d’autres valeurs offrent deux possibilités : Indiquer une valeur unique, qui sera réutilisée sur tout le vecteur, ou combiner le vecteur avec un autre vecteur de même longueur",
    "crumbs": [
      "Débuter R",
      "Les bases"
    ]
  },
  {
    "objectID": "pages/3_poo.html#les-fonctions",
    "href": "pages/3_poo.html#les-fonctions",
    "title": "Les bases",
    "section": "Les fonctions",
    "text": "Les fonctions\nUne fonction est une action qui va permettre d’agir sur un objet (l’afficher, le modifier, le combiner avec un autre…)",
    "crumbs": [
      "Débuter R",
      "Les bases"
    ]
  },
  {
    "objectID": "pages/3_poo.html#sec-classes",
    "href": "pages/3_poo.html#sec-classes",
    "title": "Les bases",
    "section": "Les classes",
    "text": "Les classes",
    "crumbs": [
      "Débuter R",
      "Les bases"
    ]
  },
  {
    "objectID": "pages/3_les_bases.html",
    "href": "pages/3_les_bases.html",
    "title": "Les bases",
    "section": "",
    "text": "Il existe différents paradigmes de programmation : par exemple les langages déclaratifs, qui consistent en l’exécution stricte d’une suite d’instruction, ou ceux orienté objet qui consistent à définir un “objet” (une donnée) via des attributs, et les faire interagir entre eux.\n\n\n\n\n\n\nPour simplifier\n\n\n\nUn langage déclaratif consisterait à dire à un robot : “Va me chercher des oeufs au supermarché qui se trouve au bout de la rue, Allée 8 sur la gauche, 3e étagère.” Un langage objet dirait plutôt : “Rends toi dans un bâtiment où il est écrit supermarché, et trouve l’article rangé au rayon ‘oeufs’, de couleur beige, de forme ovale, vendu par 12”.\n\n\nR est un langage multi-paradigme, à la fois déclaratif et orienté objet, mais surtout fonctionnel, c’est-à-dire basé sur les fonctions. Les données sont stockées sous forme d’objets, et sont modifiées par des fonctions, comme sur une ligne d’assemblage d’une usine.\n\n\n\nUn objet initial A passe au travers d’une fonction et se retrouve modifié\n\n\nLa nature d’un objet (tableau, liste, graphe) est déterminée par sa classe\n\n\nUn objet est comme un boîte qui va enregistrer des valeurs, pour ensuite interagir avec. On créé un objet en lui donnant un nom, puis on lui attribue une valeur avec la flèche d’assignation &lt;-\nEn appelant l’objet, on obtient sa valeur\nExemple :\n\n\n\n\n\n\n\n\nUn objet peut contenir plusieurs valeurs, souvent regroupées sous la forme de vecteurs\nUn vecteur est une suite de valeur de même classe (détaillé dans la partie “Les classes” ), que l’on créé en regroupant les valeurs avec la fonction c()\n\n\n\n\n\n\n\n\nEn R, certaines fonctions sont dites scalaires : elles s’appliquent sur tout un vecteur et renvoient une seule valeur. A l’inverse, certaines sont dites vectorisées, car elles s’appliquent sur toutes les valeurs d’un vecteur. Les fonctions vectorisées qui combinent un vecteur avec d’autres valeurs offrent deux possibilités : Indiquer une valeur unique, qui sera réutilisée sur tout le vecteur, ou combiner le vecteur avec un autre vecteur de même longueur\n\n\n\n\n\n\n\n\n\n\n\nUne fonction est une action qui va permettre d’agir sur un objet (l’afficher, le modifier, le combiner avec un autre…)\nUne fonction est appelée via son nom, toujours suivie de parenthèses. Exemple : sum(). \nEntre les parenthèses, on notera souvent l’objet ou les valeurs à transformer et parfois des options pour modifier l’effet de la fonction. On dit que la fonction prend des arguments. \nChaque fonction accepte différents arguments et peut posséder une grammaire différente. Pour savoir comment utiliser une fonction, on peut taper ?fonction dans la console. Essayons par exemple avec la fonction mean().\n\n\n\n\n\n\n\n\nLa documentation de chaque fonction inclut toujours :\n\nDescription : Ce que fait la fonction\nUsage : Comment l’écrire\nArguments : Le détail des arguments acceptés\nValue : Ce qui sort de la fonction\nExamples : Des exemples d’utilisation de la fonction\n\n\n\n\nsimples : numeric, character, int, logical\ncomplexes : data.frame, list, matrix",
    "crumbs": [
      "Débuter R",
      "Les bases"
    ]
  },
  {
    "objectID": "pages/3_les_bases.html#les-objets",
    "href": "pages/3_les_bases.html#les-objets",
    "title": "Les bases",
    "section": "",
    "text": "Un objet est comme un boîte qui va enregistrer des valeurs, pour ensuite interagir avec. On créé un objet en lui donnant un nom, puis on lui attribue une valeur avec la flèche d’assignation &lt;-\nEn appelant l’objet, on obtient sa valeur\nExemple :\n\n\n\n\n\n\n\n\nUn objet peut contenir plusieurs valeurs, souvent regroupées sous la forme de vecteurs\nUn vecteur est une suite de valeur de même classe (détaillé dans la partie “Les classes” ), que l’on créé en regroupant les valeurs avec la fonction c()\n\n\n\n\n\n\n\n\nEn R, certaines fonctions sont dites scalaires : elles s’appliquent sur tout un vecteur et renvoient une seule valeur. A l’inverse, certaines sont dites vectorisées, car elles s’appliquent sur toutes les valeurs d’un vecteur. Les fonctions vectorisées qui combinent un vecteur avec d’autres valeurs offrent deux possibilités : Indiquer une valeur unique, qui sera réutilisée sur tout le vecteur, ou combiner le vecteur avec un autre vecteur de même longueur",
    "crumbs": [
      "Débuter R",
      "Les bases"
    ]
  },
  {
    "objectID": "pages/3_les_bases.html#les-fonctions",
    "href": "pages/3_les_bases.html#les-fonctions",
    "title": "Les bases",
    "section": "",
    "text": "Une fonction est une action qui va permettre d’agir sur un objet (l’afficher, le modifier, le combiner avec un autre…)\nUne fonction est appelée via son nom, toujours suivie de parenthèses. Exemple : sum(). \nEntre les parenthèses, on notera souvent l’objet ou les valeurs à transformer et parfois des options pour modifier l’effet de la fonction. On dit que la fonction prend des arguments. \nChaque fonction accepte différents arguments et peut posséder une grammaire différente. Pour savoir comment utiliser une fonction, on peut taper ?fonction dans la console. Essayons par exemple avec la fonction mean().\n\n\n\n\n\n\n\n\nLa documentation de chaque fonction inclut toujours :\n\nDescription : Ce que fait la fonction\nUsage : Comment l’écrire\nArguments : Le détail des arguments acceptés\nValue : Ce qui sort de la fonction\nExamples : Des exemples d’utilisation de la fonction",
    "crumbs": [
      "Débuter R",
      "Les bases"
    ]
  },
  {
    "objectID": "pages/3_les_bases.html#sec-classes",
    "href": "pages/3_les_bases.html#sec-classes",
    "title": "Les bases",
    "section": "",
    "text": "simples : numeric, character, int\ncomplexes : data.frame, list, matrix",
    "crumbs": [
      "Débuter R",
      "Les bases"
    ]
  },
  {
    "objectID": "index.html#visualisation-3d",
    "href": "index.html#visualisation-3d",
    "title": "Introduction",
    "section": "Visualisation 3D",
    "text": "Visualisation 3D\n\nCodegraphe\n\n\n\nlibrary(rgl)\ndata &lt;- iris\n\nmycolors &lt;- c('royalblue1', 'darkcyan', 'oldlace')\ndata$color &lt;- mycolors[ as.numeric(data$Species) ]\n\nplot3d( \n  x = data$`Sepal.Length`,\n  y = data$`Sepal.Width`,\n  z = data$`Petal.Length`, \n  col = data$color, \n  type = 's', \n  radius = .1,\n  xlab = \"Sepal Length\", \n  ylab = \"Sepal Width\", \n  zlab = \"Petal Length\")\n\n\n\n\n\nWarning: le package 'htmlwidgets' a été compilé avec la version R 4.3.3",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "pages/1_histoire.html#mémoire-magnétique",
    "href": "pages/1_histoire.html#mémoire-magnétique",
    "title": "Histoire de la programmation",
    "section": "Mémoire magnétique",
    "text": "Mémoire magnétique\nPage wikipédia : Tores magnétiques - Chaînes de tores",
    "crumbs": [
      "Histoire de la programmation"
    ]
  },
  {
    "objectID": "presentations/presentation_1.html#outils-nocode",
    "href": "presentations/presentation_1.html#outils-nocode",
    "title": "Introduction à R  et à la gestion de données",
    "section": "Outils “nocode”",
    "text": "Outils “nocode”\n\nlibrary(GWalkR)\ngwalkr(iris)"
  },
  {
    "objectID": "presentations/presentation_1.html#fonctionnement",
    "href": "presentations/presentation_1.html#fonctionnement",
    "title": "Introduction à R  et à la gestion de données",
    "section": "Fonctionnement",
    "text": "Fonctionnement\n\nFonctionnement d’un métier à tisser Jacquard\nLa perforation des cartes permet ou non de laisser passer l’aiguille. Les aiguilles repoussées retirent le crochet de la poutre en haut. En appuyant sur la pédale, les crochets prédéfinis soulèvent les fils, permettant d’y passer la trame d’un autre tissu pour former des motifs"
  },
  {
    "objectID": "presentations/presentation_1.html#cartes-perforées",
    "href": "presentations/presentation_1.html#cartes-perforées",
    "title": "Introduction à R  et à la gestion de données",
    "section": "Cartes perforées",
    "text": "Cartes perforées\nLe concept de programmer une machine date d’avant l’apparition de l’informatique, avec l’apparition des cartes perforées\n\n\n\nMétier à tisser jacquard, fonctionnant avec des cartes perforées, mises au point en 1725 à Lyon par Basile Bouchon\n\n\n\n\n\nFonctionnement d’un métier à tisser Jacquard"
  },
  {
    "objectID": "presentations/presentation_1.html#débuts-de-linformatique",
    "href": "presentations/presentation_1.html#débuts-de-linformatique",
    "title": "Introduction à R  et à la gestion de données",
    "section": "Débuts de l’informatique",
    "text": "Débuts de l’informatique\n1890, Herman Hollerith dépose un brevet pour une machine à calculer, en se basant sur les travaux théoriques de Charles Babbage et Ada Lovelace.\nCes machines permettront d’aider au recensement des Etats-unis en automatisant les calculs\n\n\n\nTabulatrice IBM 401, 1948\n\n\n\n\n\nCartes perforées Hollerith"
  },
  {
    "objectID": "presentations/presentation_1.html#débuter-r",
    "href": "presentations/presentation_1.html#débuter-r",
    "title": "Introduction à R  et à la gestion de données",
    "section": "Débuter R",
    "text": "Débuter R\n\n#| edit: true\n\n1+1"
  },
  {
    "objectID": "presentations/presentation_1.html#objectifs-du-cours",
    "href": "presentations/presentation_1.html#objectifs-du-cours",
    "title": "Introduction à R  et à la gestion de données",
    "section": "Objectifs du cours",
    "text": "Objectifs du cours\n\n\n\nComprendre les bases de la programmation\n\nLe fonctionnement d’un langage de programmation\nLes types de données\nL’utilisation des fonctions\n\n\n\n\nDécouvrir la programmation en R pour :\n\nImporter, vérifier et nettoyer des données\nRéaliser des statistiques simples (univariées)\nCréer des graphes"
  },
  {
    "objectID": "presentations/presentation_1.html#statistiques-descriptives",
    "href": "presentations/presentation_1.html#statistiques-descriptives",
    "title": "Introduction à R  et à la gestion de données",
    "section": "Statistiques descriptives",
    "text": "Statistiques descriptives\n\nDataAnalyse\n\n\n\niris\n\n    Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n1            5.1         3.5          1.4         0.2     setosa\n2            4.9         3.0          1.4         0.2     setosa\n3            4.7         3.2          1.3         0.2     setosa\n4            4.6         3.1          1.5         0.2     setosa\n5            5.0         3.6          1.4         0.2     setosa\n6            5.4         3.9          1.7         0.4     setosa\n7            4.6         3.4          1.4         0.3     setosa\n8            5.0         3.4          1.5         0.2     setosa\n9            4.4         2.9          1.4         0.2     setosa\n10           4.9         3.1          1.5         0.1     setosa\n11           5.4         3.7          1.5         0.2     setosa\n12           4.8         3.4          1.6         0.2     setosa\n13           4.8         3.0          1.4         0.1     setosa\n14           4.3         3.0          1.1         0.1     setosa\n15           5.8         4.0          1.2         0.2     setosa\n16           5.7         4.4          1.5         0.4     setosa\n17           5.4         3.9          1.3         0.4     setosa\n18           5.1         3.5          1.4         0.3     setosa\n19           5.7         3.8          1.7         0.3     setosa\n20           5.1         3.8          1.5         0.3     setosa\n21           5.4         3.4          1.7         0.2     setosa\n22           5.1         3.7          1.5         0.4     setosa\n23           4.6         3.6          1.0         0.2     setosa\n24           5.1         3.3          1.7         0.5     setosa\n25           4.8         3.4          1.9         0.2     setosa\n26           5.0         3.0          1.6         0.2     setosa\n27           5.0         3.4          1.6         0.4     setosa\n28           5.2         3.5          1.5         0.2     setosa\n29           5.2         3.4          1.4         0.2     setosa\n30           4.7         3.2          1.6         0.2     setosa\n31           4.8         3.1          1.6         0.2     setosa\n32           5.4         3.4          1.5         0.4     setosa\n33           5.2         4.1          1.5         0.1     setosa\n34           5.5         4.2          1.4         0.2     setosa\n35           4.9         3.1          1.5         0.2     setosa\n36           5.0         3.2          1.2         0.2     setosa\n37           5.5         3.5          1.3         0.2     setosa\n38           4.9         3.6          1.4         0.1     setosa\n39           4.4         3.0          1.3         0.2     setosa\n40           5.1         3.4          1.5         0.2     setosa\n41           5.0         3.5          1.3         0.3     setosa\n42           4.5         2.3          1.3         0.3     setosa\n43           4.4         3.2          1.3         0.2     setosa\n44           5.0         3.5          1.6         0.6     setosa\n45           5.1         3.8          1.9         0.4     setosa\n46           4.8         3.0          1.4         0.3     setosa\n47           5.1         3.8          1.6         0.2     setosa\n48           4.6         3.2          1.4         0.2     setosa\n49           5.3         3.7          1.5         0.2     setosa\n50           5.0         3.3          1.4         0.2     setosa\n51           7.0         3.2          4.7         1.4 versicolor\n52           6.4         3.2          4.5         1.5 versicolor\n53           6.9         3.1          4.9         1.5 versicolor\n54           5.5         2.3          4.0         1.3 versicolor\n55           6.5         2.8          4.6         1.5 versicolor\n56           5.7         2.8          4.5         1.3 versicolor\n57           6.3         3.3          4.7         1.6 versicolor\n58           4.9         2.4          3.3         1.0 versicolor\n59           6.6         2.9          4.6         1.3 versicolor\n60           5.2         2.7          3.9         1.4 versicolor\n61           5.0         2.0          3.5         1.0 versicolor\n62           5.9         3.0          4.2         1.5 versicolor\n63           6.0         2.2          4.0         1.0 versicolor\n64           6.1         2.9          4.7         1.4 versicolor\n65           5.6         2.9          3.6         1.3 versicolor\n66           6.7         3.1          4.4         1.4 versicolor\n67           5.6         3.0          4.5         1.5 versicolor\n68           5.8         2.7          4.1         1.0 versicolor\n69           6.2         2.2          4.5         1.5 versicolor\n70           5.6         2.5          3.9         1.1 versicolor\n71           5.9         3.2          4.8         1.8 versicolor\n72           6.1         2.8          4.0         1.3 versicolor\n73           6.3         2.5          4.9         1.5 versicolor\n74           6.1         2.8          4.7         1.2 versicolor\n75           6.4         2.9          4.3         1.3 versicolor\n76           6.6         3.0          4.4         1.4 versicolor\n77           6.8         2.8          4.8         1.4 versicolor\n78           6.7         3.0          5.0         1.7 versicolor\n79           6.0         2.9          4.5         1.5 versicolor\n80           5.7         2.6          3.5         1.0 versicolor\n81           5.5         2.4          3.8         1.1 versicolor\n82           5.5         2.4          3.7         1.0 versicolor\n83           5.8         2.7          3.9         1.2 versicolor\n84           6.0         2.7          5.1         1.6 versicolor\n85           5.4         3.0          4.5         1.5 versicolor\n86           6.0         3.4          4.5         1.6 versicolor\n87           6.7         3.1          4.7         1.5 versicolor\n88           6.3         2.3          4.4         1.3 versicolor\n89           5.6         3.0          4.1         1.3 versicolor\n90           5.5         2.5          4.0         1.3 versicolor\n91           5.5         2.6          4.4         1.2 versicolor\n92           6.1         3.0          4.6         1.4 versicolor\n93           5.8         2.6          4.0         1.2 versicolor\n94           5.0         2.3          3.3         1.0 versicolor\n95           5.6         2.7          4.2         1.3 versicolor\n96           5.7         3.0          4.2         1.2 versicolor\n97           5.7         2.9          4.2         1.3 versicolor\n98           6.2         2.9          4.3         1.3 versicolor\n99           5.1         2.5          3.0         1.1 versicolor\n100          5.7         2.8          4.1         1.3 versicolor\n101          6.3         3.3          6.0         2.5  virginica\n102          5.8         2.7          5.1         1.9  virginica\n103          7.1         3.0          5.9         2.1  virginica\n104          6.3         2.9          5.6         1.8  virginica\n105          6.5         3.0          5.8         2.2  virginica\n106          7.6         3.0          6.6         2.1  virginica\n107          4.9         2.5          4.5         1.7  virginica\n108          7.3         2.9          6.3         1.8  virginica\n109          6.7         2.5          5.8         1.8  virginica\n110          7.2         3.6          6.1         2.5  virginica\n111          6.5         3.2          5.1         2.0  virginica\n112          6.4         2.7          5.3         1.9  virginica\n113          6.8         3.0          5.5         2.1  virginica\n114          5.7         2.5          5.0         2.0  virginica\n115          5.8         2.8          5.1         2.4  virginica\n116          6.4         3.2          5.3         2.3  virginica\n117          6.5         3.0          5.5         1.8  virginica\n118          7.7         3.8          6.7         2.2  virginica\n119          7.7         2.6          6.9         2.3  virginica\n120          6.0         2.2          5.0         1.5  virginica\n121          6.9         3.2          5.7         2.3  virginica\n122          5.6         2.8          4.9         2.0  virginica\n123          7.7         2.8          6.7         2.0  virginica\n124          6.3         2.7          4.9         1.8  virginica\n125          6.7         3.3          5.7         2.1  virginica\n126          7.2         3.2          6.0         1.8  virginica\n127          6.2         2.8          4.8         1.8  virginica\n128          6.1         3.0          4.9         1.8  virginica\n129          6.4         2.8          5.6         2.1  virginica\n130          7.2         3.0          5.8         1.6  virginica\n131          7.4         2.8          6.1         1.9  virginica\n132          7.9         3.8          6.4         2.0  virginica\n133          6.4         2.8          5.6         2.2  virginica\n134          6.3         2.8          5.1         1.5  virginica\n135          6.1         2.6          5.6         1.4  virginica\n136          7.7         3.0          6.1         2.3  virginica\n137          6.3         3.4          5.6         2.4  virginica\n138          6.4         3.1          5.5         1.8  virginica\n139          6.0         3.0          4.8         1.8  virginica\n140          6.9         3.1          5.4         2.1  virginica\n141          6.7         3.1          5.6         2.4  virginica\n142          6.9         3.1          5.1         2.3  virginica\n143          5.8         2.7          5.1         1.9  virginica\n144          6.8         3.2          5.9         2.3  virginica\n145          6.7         3.3          5.7         2.5  virginica\n146          6.7         3.0          5.2         2.3  virginica\n147          6.3         2.5          5.0         1.9  virginica\n148          6.5         3.0          5.2         2.0  virginica\n149          6.2         3.4          5.4         2.3  virginica\n150          5.9         3.0          5.1         1.8  virginica\n\n\n\n\n\nsummary(iris)\n\n  Sepal.Length    Sepal.Width     Petal.Length    Petal.Width   \n Min.   :4.300   Min.   :2.000   Min.   :1.000   Min.   :0.100  \n 1st Qu.:5.100   1st Qu.:2.800   1st Qu.:1.600   1st Qu.:0.300  \n Median :5.800   Median :3.000   Median :4.350   Median :1.300  \n Mean   :5.843   Mean   :3.057   Mean   :3.758   Mean   :1.199  \n 3rd Qu.:6.400   3rd Qu.:3.300   3rd Qu.:5.100   3rd Qu.:1.800  \n Max.   :7.900   Max.   :4.400   Max.   :6.900   Max.   :2.500  \n       Species  \n setosa    :50  \n versicolor:50  \n virginica :50"
  },
  {
    "objectID": "pages/TP1.html",
    "href": "pages/TP1.html",
    "title": "TP 1",
    "section": "",
    "text": "Documents\n\n\n\nProblématique :\nLa greffe de cellules souches hématopoïétiques (HSCT) est une thérapies des hémopathies malignes (leucémies, lymphomes, myélomes) et à d’autres troubles hématologiques (p. ex., déficit immunitaire primitif, aplasie médullaire, myélodysplasie). La greffe de cellules souches hématopoïétiques est aussi parfois utilisée pour les tumeurs solides (p. ex., certaines tumeurs des cellules germinales) qui répondent à la chimiothérapie.\nCette greffe permet la restauration de moelle osseuse après des traitements myéloablatifs contre le cancer, ou le remplacement de la moelle osseuse anormale par une saine.\nL’une des principales complications de cette greffe est l’infection au cytomégalovirus (CMV). Chez la plupart des gens, l’infection au CMV est quasiment invisible, car asymptomatique, et des gens peuvent vivre avec un virus “dormant” durant de nombreuses années. Ainsi, la plupart des porteurs ignorent qu’ils sont infectés. Cependant chez les femmes enceintes ou les personnes avec un système immunitaire affaibli, l’infection peut être fatale.\nDans le cas où un patient serait porteur asymptomatique du virus, puis subirait une immunosuppression dans le cadre d’un traitement, il existe une possibilité de réaction du virus, provoquant une surmortalité des patients concernés.\nLes cellules NK (Natural Killer) et les lymphocytes T jouent un rôle de protection contre la réactivation du CMV. La réactivité de ces cellules est régulée par l’interaction des KIRs (Killer Immunoglobulin-like Receptor, un récepteur présent sur la membrane des NK) avec les cellules HLA de classe 1 (le système HLA permet de différencier les cellules du soi et les corps étrangers). Le gène producteur des KIRs est fortement polymorphique (il en existe différentes versions).\nUne hypothèse est que le génotype KIR du donneur a un impact sur la réactivation du CMV après une HSCT.\n\n\nObjectif du TP :\n\nLire les documents et comprendre la problématique\nExplorer le jeu de données\nRéaliser des statistiques simples sur le jeu de données (moyenne, min, max, différences)\nTrouver une méthodologie qui permettrait de parvenir à une conclusion\nRépondre à l’hypothèse de départ\n\n\n\nLes données :\n\n\n\n\n\n\n\n\n\n\n\nExercices\nLa fonction group_by() permet de “découper” en data.frame en regroupant toutes les lignes dont la valeur est la même pour une colonne définie. La fonction summarize() est une fonction d’aggrégation, qui permet de créér un nouveau jeu de données où chaque colonne est l’aggrégation d’une autre. Exemple :\n\n\n\n\n\n\n\n\n\n\nSources :\nTransplantation de cellules-souches hématopoïétiques\nExpert consensus on the management of cytomegalovirus infection in pediatric allogeneic hematopoietic stem cell transplantation\nThe extensive polymorphism of KIR genes\nCalculate the average of all of the integers from 1 to 10.",
    "crumbs": [
      "TP 1"
    ]
  },
  {
    "objectID": "pages/3_les_bases.html#les-classes",
    "href": "pages/3_les_bases.html#les-classes",
    "title": "Les bases",
    "section": "",
    "text": "simples : numeric, character, int, logical\ncomplexes : data.frame, list, matrix",
    "crumbs": [
      "Débuter R",
      "Les bases"
    ]
  },
  {
    "objectID": "pages/TP1.html#documents",
    "href": "pages/TP1.html#documents",
    "title": "TP 1",
    "section": "Documents",
    "text": "Documents",
    "crumbs": [
      "TP 1"
    ]
  },
  {
    "objectID": "pages/TP1.html#problématique",
    "href": "pages/TP1.html#problématique",
    "title": "TP 1",
    "section": "Problématique :",
    "text": "Problématique :\nLa greffe de cellules souches hématopoïétiques (HSCT) est une thérapies des hémopathies malignes (leucémies, lymphomes, myélomes) et à d’autres troubles hématologiques (p. ex., déficit immunitaire primitif, aplasie médullaire, myélodysplasie). La greffe de cellules souches hématopoïétiques est aussi parfois utilisée pour les tumeurs solides (p. ex., certaines tumeurs des cellules germinales) qui répondent à la chimiothérapie.\nCette greffe permet la restauration de moelle osseuse après des traitements myéloablatifs contre le cancer, ou le remplacement de la moelle osseuse anormale par une saine.\nL’une des principales complications de cette greffe est l’infection au cytomégalovirus (CMV). Chez la plupart des gens, l’infection au CMV est quasiment invisible, car asymptomatique, et des gens peuvent vivre avec un virus “dormant” durant de nombreuses années. Ainsi, la plupart des porteurs ignorent qu’ils sont infectés. Cependant chez les femmes enceintes ou les personnes avec un système immunitaire affaibli, l’infection peut être fatale.\nDans le cas où un patient serait porteur asymptomatique du virus, puis subirait une immunosuppression dans le cadre d’un traitement, il existe une possibilité de réaction du virus, provoquant une surmortalité des patients concernés.\nLes cellules NK (Natural Killer) et les lymphocytes T jouent un rôle de protection contre la réactivation du CMV. La réactivité de ces cellules est régulée par l’interaction des KIRs (Killer Immunoglobulin-like Receptor, un récepteur présent sur la membrane des NK) avec les cellules HLA de classe 1 (le système HLA permet de différencier les cellules du soi et les corps étrangers). Le gène producteur des KIRs est fortement polymorphique (il en existe différentes versions).\nUne hypothèse est que le génotype KIR du donneur a un impact sur la réactivation du CMV après une HSCT.",
    "crumbs": [
      "TP 1"
    ]
  },
  {
    "objectID": "pages/TP1.html#objectif-du-tp",
    "href": "pages/TP1.html#objectif-du-tp",
    "title": "TP 1",
    "section": "Objectif du TP :",
    "text": "Objectif du TP :\n\nLire les documents et comprendre la problématique\nExplorer le jeu de données\nRéaliser des statistiques simples sur le jeu de données (moyenne, min, max, différences)\nTrouver une méthodologie qui permettrait de parvenir à une conclusion\nRépondre à l’hypothèse de départ",
    "crumbs": [
      "TP 1"
    ]
  },
  {
    "objectID": "pages/TP1.html#les-données",
    "href": "pages/TP1.html#les-données",
    "title": "TP 1",
    "section": "Les données :",
    "text": "Les données :",
    "crumbs": [
      "TP 1"
    ]
  },
  {
    "objectID": "pages/Les_bases.html",
    "href": "pages/Les_bases.html",
    "title": "Les bases",
    "section": "",
    "text": "Rappel des bases\nR est un langage de programmation fait pour l’analyse de données et les statistiques\nUn objet permet de stocker des valeurs. On créé un objet en lui donnant un nom, et on lui assigne une valeur avec la flèche d’assignation &lt;-\n\n\n\n\n\n\n\n\nChaque valeur appartient à une (ou plusieurs) classes, qui définissent sa nature\n\n\n\n\n\n\n\n\nOn regroupe plusieurs valeurs dans des vecteurs. Un vecteur ne contient que des valeurs de même classe\n\n\n\n\n\n\n\n\nLes dataframes sont une classe d’objets correspondant à des tableaux (format Excel par exemple). Chaque colonne est un vecteur\n\n\n\n\n\n\n\n\nLes fonctions permettent d’interagir avec les objets, afin de les modifier. On écrit toujours une fonction avec des parenthèses à la fin, en indiquant au milieu l’objet sur lequel on l’applique et si besoin les arguments (options) à activer. Certaines fonctions sont vectorisées et renvoient un vecteur de même longueur modifié, d’autres sont des fonctions d’aggrégation et renvoient une seule valeur pour tout un vecteur (somme, nombre de valeurs, etc)\n\n\n\n\n\n\n\n\n{dplyr} est un package, une extension, qui permet d’appliquer des fonctions en chaîne en utilisant l’opérateur %&gt;% (pipe), avec une logique de chaîne d’assemblage sur une usine. Par exemple : on souhaite filtrer le jeu de données iris, puis sélectionner deux colonnes.\n\n\n\n\n\n\n\n\nLes fonctions en R ont généralement un nom simple, en anglais, qui correspond à ce qu’elles font : mean(), min(), max(), median(), sqrt(), sont des fonctions permettant de calculer respectivement la moyenne, le minimum, le maximum, la médiane et la racine carrée d’un vecteur numérique.\nfilter() permet de filtrer les lignes d’un tableau, et select() permet de sélectionner les colonnes.",
    "crumbs": [
      "Les bases"
    ]
  },
  {
    "objectID": "pages/TP1.html#exercice-1",
    "href": "pages/TP1.html#exercice-1",
    "title": "TP 1",
    "section": "Exercice 1",
    "text": "Exercice 1\n\n\n\n\n\n\nNote\n\n\n\nLe jeu de données s’appelle cytomegalovirus, mais pour faire court, on appellera l’objet cyto dans les exercices\n\n\n\n\n\n\n\n\n\n\nLa fonction count() permet d’afficher le nombre de lignes d’un jeu de données. Si on lui donne le nom d’une colonne en argument, elle affiche le nombre de ligne pour chaque valeur différente de cette colonne.\nAffichez le nombre d’hommes et de femmes\n\n\n\n\n\n\n\n\n\n\n\nAvec les fonctions group_by() et summarize() vues plus tôt, affichez le minimum, le maximum et la moyenne d’âge par sexe",
    "crumbs": [
      "TP 1"
    ]
  },
  {
    "objectID": "pages/TP1.html#exercice-1-explorer-les-données",
    "href": "pages/TP1.html#exercice-1-explorer-les-données",
    "title": "TP 1",
    "section": "Exercice 1 : Explorer les données",
    "text": "Exercice 1 : Explorer les données\n\n\n\n\n\n\nNote\n\n\n\nLe jeu de données s’appelle cytomegalovirus, mais pour faire court, on appellera l’objet cyto dans les exercices\n\n\n\n\n\n\n\n\n\n\nLa fonction count() permet d’afficher le nombre de lignes d’un jeu de données. Si on lui donne le nom d’une colonne en argument, elle affiche le nombre de ligne pour chaque valeur différente de cette colonne.\nAffichez le nombre d’hommes et de femmes\n\n\n\n\n\n\n\n\n\n\n\nAvec les fonctions group_by() et summarize() vues plus tôt, affichez le minimum, le maximum et la moyenne d’âge par sexe",
    "crumbs": [
      "TP 1"
    ]
  },
  {
    "objectID": "pages/TP1.html#exercice-2-nettoyer-les-données",
    "href": "pages/TP1.html#exercice-2-nettoyer-les-données",
    "title": "TP 1",
    "section": "Exercice 2 : Nettoyer les données",
    "text": "Exercice 2 : Nettoyer les données\nLa fonction summary(), utilisée sur un dataframe, permet de visualiser de nombreuses informations sur un jeu de données.\n\n\n\n\n\n\n\n\nProblème : on remarque que des variables comme le sexe ou l’ethnie sont codées en 0/1 et apparaissent comme des valeurs numériques. On souhaite recoder ces variables dans la classe factor. \nUn vecteur de classe factor contient des valeurs appartenant à une liste pré-établie (pas du texte libre, donc). On attribue une valeur arbitraire à chaque réponse, et les données sont stockées au format numérique. Par exemple, pour coder la variable sex en factor, R attribuera la valeur 1 à la première valeur qui apparait, puis 2, etc… On aura par exemple 1 = “Femme” et 2 = “Homme”, avec un vecteur contenant les valeurs c(1,2,2,2,1,1,2,1,2,1,2). Le vecteur contient donc des nombres, mais qui ne sont pas considérés comme des valeurs numériques.\nPour modifier la colonne d’un dataframe, on utilise la fonction mutate(), généralement avec :\n\n\n\n\n\n\n\n\nMais lorsque l’on souhaite modifier plusieurs colonnes d’un coup, on peut utiliser la variante mutate_at(). Cette fonction prend deux arguments : un vecteur de classe character contenant la liste des colonnes à modifier, et le nom de la fonction à appliquer\nConsigne : A partir du dictionnaire des données, identifiez les variables de classe facteur, et modifiez-les pour avoir un summary() pertinent\n\n\n\n\n\n\n\n\n\n\n\nLe résultat du summary() est désormais plus clair, mais on souhaite avoir dans le résultat le label des variables factor. Pour cela, on utilisera le package {forcats}.",
    "crumbs": [
      "TP 1"
    ]
  },
  {
    "objectID": "pages/TP1.html#exercice-3-visualiser-les-données",
    "href": "pages/TP1.html#exercice-3-visualiser-les-données",
    "title": "TP 1",
    "section": "Exercice 3 : Visualiser les données",
    "text": "Exercice 3 : Visualiser les données\nLe package {ggplot2} permet de générer des graphes à partir des données d’un dataframe. La fonction ggplot() fonctionne par “couches”, ou layers : on commence par créer les coordonnées (axe X,Y), puis on définit les points/lignes à afficher dans ggplot(), on utilise la fonction aes() (pour aesthetics) pour définir les axes, et on définit ensuite le type de graphe à afficher avec les fonctions geom_* (geom_point, geom_line, geom_histogram…)\nVisualiser le temps de réactivation en fonction des aKIRs, par statut du donneur\n\n\n\n\n\n\n\n\n\n\n\nUne façon plus interactive de visualiser les données est d’utiliser le package {GWalkR} :",
    "crumbs": [
      "TP 1"
    ]
  },
  {
    "objectID": "pages/TP1.html#test-statistique",
    "href": "pages/TP1.html#test-statistique",
    "title": "TP 1",
    "section": "Test statistique",
    "text": "Test statistique\nOn souhaite réaliser un t.test pour savoir si les KIRs évoluent en fonction du statut cmv :",
    "crumbs": [
      "TP 1"
    ]
  },
  {
    "objectID": "pages/TP2.html",
    "href": "pages/TP2.html",
    "title": "TP 2",
    "section": "",
    "text": "Dans ce TP, on explorera le jeu de données microorganisms, qu’on appellera micro, et example_isolates qui contient les données de sensibilité aux antibiotiques de patients infectés par différents microorganismes.",
    "crumbs": [
      "TP 2"
    ]
  },
  {
    "objectID": "pages/TP2.html#micro",
    "href": "pages/TP2.html#micro",
    "title": "TP 2",
    "section": "micro",
    "text": "micro",
    "crumbs": [
      "TP 2"
    ]
  },
  {
    "objectID": "pages/TP2.html#example_isolates",
    "href": "pages/TP2.html#example_isolates",
    "title": "TP 2",
    "section": "example_isolates",
    "text": "example_isolates",
    "crumbs": [
      "TP 2"
    ]
  },
  {
    "objectID": "pages/TP2.html#exploration",
    "href": "pages/TP2.html#exploration",
    "title": "TP 2",
    "section": "Exploration",
    "text": "Exploration\n\n\n\n\n\n\n\n\nRetrouver le nom complet de B_STRPT_PNMN\n\n\n\n\n\n\n\n\nEvaluer la sensibilité d’e.coli (B_ESCHR_COLI) à la Penicilline\n\n\n\n\n\n\n\n\n\n\n\nCONSIGNE : Chercher Escherichia Coli et Streptococcus pneumoniae. Sont-elles sensibles à la penicilline ? Pourquoi ?",
    "crumbs": [
      "TP 2"
    ]
  },
  {
    "objectID": "pages/TP2.html#nettoyage",
    "href": "pages/TP2.html#nettoyage",
    "title": "TP 2",
    "section": "Nettoyage",
    "text": "Nettoyage\nPour rendre les donneés plus lisibles, on va pivoter la table\n\n\n\n\n\n\n\n\nIdentifier le pourcentage de résistance à chaque antibiotique",
    "crumbs": [
      "TP 2"
    ]
  },
  {
    "objectID": "pages/TP2.html#visualiser-les-données",
    "href": "pages/TP2.html#visualiser-les-données",
    "title": "TP 2",
    "section": "Visualiser les données",
    "text": "Visualiser les données",
    "crumbs": [
      "TP 2"
    ]
  },
  {
    "objectID": "pages/TP3.html",
    "href": "pages/TP3.html",
    "title": "TP 3",
    "section": "",
    "text": "Par abus de langage, on parle souvent “du cancer” comme d’une seule maladie. En réalité il existe de nombreuses formes et différents mécanismes de cancer, en fonction des tissus touchés ou de certaines mutations génétiques.\nDans le cancer du sein, il existe trois mutations génétiques principales qui font fortement varier le pronostic des patientes, et qui sont systématiquement recherchées avant de débuter un traitement. Ces trois gènes sont ceux des récepteurs à la progestérone, des récepteurs aux oestrogènes et le gène HER2. Les options thérapeutiques disponibles pour les patientes varient fortement en fonction de ce profil génétique.\nPour ce TP, nous allons imaginer une étude clinique portant sur un nouveau traitement pour le cancer du sein. Le jeu de données à votre disposition contient des données sur l’age, le sexe, le profil génétique et l’évolution de la maladie.",
    "crumbs": [
      "TP 3"
    ]
  },
  {
    "objectID": "pages/TP3.html#dictionnaire-des-données",
    "href": "pages/TP3.html#dictionnaire-des-données",
    "title": "TP 3",
    "section": "Dictionnaire des données",
    "text": "Dictionnaire des données",
    "crumbs": [
      "TP 3"
    ]
  },
  {
    "objectID": "pages/TP3.html#exploration",
    "href": "pages/TP3.html#exploration",
    "title": "TP 3",
    "section": "Exploration",
    "text": "Exploration\nComme dans les TP précédents, utilisez summary() pour visualiser rapidement les données. Le dataframe s’appelera df",
    "crumbs": [
      "TP 3"
    ]
  },
  {
    "objectID": "pages/TP3.html#nettoyage",
    "href": "pages/TP3.html#nettoyage",
    "title": "TP 3",
    "section": "Nettoyage",
    "text": "Nettoyage\nRetirez les hommes du jeu de données\n\n\n\n\n\n\n\n\nUtilisez la fonction mutate() et case_when() pour modifier les variables “*_yn” et recoder les 0/1 en non/oui\n\n\n\n\n\n\nTip\n\n\n\nLe symbole ~ (tilde) peut signifier “prend la valeur” ou “en fonction de”\n\n\nRecodez également la variable “sexe” pour afficher “Femmes” au lieu de 0\n\n\n\n\n\n\n\n\nCréez une nouvelle colonne “genotype” qui combine les 3 colonnes “er”,“pr” et “her2. Si er ou pr est positive, on dit que la patiente est”RH+” (rh = récepteur aux hormones), sinon “RH-” Le génotype se compose de RH+/- et HER2+/-\n\n\n\n\n\n\nTip\n\n\n\nVous pouvez utiliser la fonction unite() et chercher la documentation associée sur internet ou en tapant ?unite() dans la console",
    "crumbs": [
      "TP 3"
    ]
  },
  {
    "objectID": "pages/TP3.html#visualisation",
    "href": "pages/TP3.html#visualisation",
    "title": "TP 3",
    "section": "Visualisation",
    "text": "Visualisation\nComplétez le code pour afficher la courbe de survie en fonction de différents facteurs.\n\n\n\n\n\n\nTip\n\n\n\nVous pouvez chercher la documentation associée au package ggsurvfit sur internet ou en tapant ?ggsurvfit dans la console. La fonction ggsurvfit() est un dérivé du package {ggplot} et permet de créer le graphe (idem pour les fonctions suivantes)",
    "crumbs": [
      "TP 3"
    ]
  }
]