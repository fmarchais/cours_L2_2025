<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Félix Marchais">
<meta name="dcterms.date" content="2025-08-12">
<meta name="description" content="insérer une description">

<title>Cours L2 – Introduction à la gestion des données avec R</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Introduction à la gestion des données avec R</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Accueil</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../intro_l2.qmd"> 
<span class="menu-text">L2</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../intro_m2.qmd"> 
<span class="menu-text">M2</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Cours L2</h1>
</div>

<div>
  <div class="description">
    insérer une description
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Félix Marchais </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">August 12, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<div style="text-align: justify">
<p><!-- commande HTML pour justifier le texte --></p>
<section id="la-bioinformatique-pourquoi-faire" class="level2">
<h2 class="anchored" data-anchor-id="la-bioinformatique-pourquoi-faire">La bioinformatique, pourquoi faire ?</h2>
<p>La biologie est une discipline qui étudie des sujets complexes : les être vivants. Cette complexité est due aux très nombreuses interactions entre les “briques” qui composent les être vivants, à différentes échelles : les interactions chimiques entre les atomes, les molécules, les protéines, les cellules, les tissus, les organes et même entre les individus. Ainsi, il est difficile d’étudier l’effet d’une protéine sans comprendre ses interactions avec le reste de l’organisme, il faut donc prendre en compte tout l’environnement autour du sujet d’étude pour bien le comprendre. </p>
<p>Le problème, c’est que lorsque l’on étudie un brin d’ADN, il est difficile de retenir les noms et les interactions des 3.000.000.000.000 paires de bases de l’ADN humain, surtout avec un papier et un crayon. </p>
<p>L’informatique est alors apparue comme une solution, dans un premier temps de stockage et de requêtage, puis de calcul, et aujourd’hui de prédiction.</p>
</section>
<section id="r-et-la-programmation" class="level1">
<h1>R et la programmation</h1>
<section id="programmer-cest-quoi" class="level2">
<h2 class="anchored" data-anchor-id="programmer-cest-quoi">Programmer, c’est quoi ?</h2>
<p>La programmation, c’est donner des instructions à un ordinateur, comme on donnerait des instructions à une calculatrice pour faire un calcul. </p>
<p>On parle de <em>langages de programmation</em> car les instructions que l’on utilise sont proches du langage naturel. Par exemple, on comprendra facilement que la commande “cos(5)” indique d’effectuer le calcul “cosinus de 5”. </p>
</section>
<section id="un-peu-dhistoire" class="level2">
<h2 class="anchored" data-anchor-id="un-peu-dhistoire">Un peu d’histoire</h2>
<p>Les premières années de l’informatique remontent vers 1890, lorsque Herman Hollerith (futur fondateur d’IBM) dépose un brevet pour une machine à calculer en se basant sur les travaux de Charles Babbage et Ada Lovelace (1842). L’objectif était d’aider au recensement des Etats-unis en automatisant les calculs, car à cette époque le recensement était réalisé tous les dix ans et nécessitait neuf ans de travail.</p>
<p>Les machines à calculer, appelés <em>tabulatrices</em> étaient électro-mécaniques et disposaient de programmes “fixes” : la machine contenait un panneau de contrôle, dans lequel le fabriquant avait “écrit” les instructions en suivant un schéma de câblage. Une machine à calculer était grosse comme un bureau et ne pouvait exécuter qu’un seul programme. Les données étaient saisies sur des cartes perforées et lues en direct par la machine. La carte perforée était lue via des aiguilles qui passaient (ou non) au travers des perforations, puis atterissaient dans un bain de mercure pour fermer un circuit électrique.</p>
<div>

</div>
<div class="quarto-layout-panel" data-layout-nrow="1">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/carte_perforée.jpg" class="img-fluid figure-img"></p>
<figcaption>Carte perforée, inspirée des tickets de trains poinçonnés en fonction de l’âge et du sexe des voyageurs</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-363242189.png" class="img-fluid figure-img"></p>
<figcaption>Tabulatrice IBM 401, 1948</figcaption>
</figure>
</div>
</div>
</div>
</div>
<p>Par la suite, des panneaux de contrôle amovibles sont apparus : pour changer de programme informatique, on changeait le panneau de contrôle. </p>
<div>

</div>
<div class="quarto-layout-panel" data-layout-nrow="1">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 33.3%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/panneau_controle_tabulatrice.jpg" class="img-fluid figure-img"></p>
<figcaption>Panneau de contrôle d’une tabulatrice</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 33.3%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/panneau_controle_tabulatrice_cable.jpg" class="img-fluid figure-img"></p>
<figcaption>Panneau de contrôle d’une tabulatrice câblé</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 33.3%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/panneau_controle_tabulatrice_schema.jpg" class="img-fluid figure-img"></p>
<figcaption>Schéma du panneau de contrôle d’une tabulatrice</figcaption>
</figure>
</div>
</div>
</div>
</div>
<p>Dans les années 1960, l’arrivée des transistors permet le début des sytèmes 100% électriques, on change alors de paradigme : un processeur unique permet de faire tous les calculs, et l’utilisateur définit le programme. Cependant, les ordinateurs ne disposent pas encore de mémoire pour se souvenir des différentes étapes d’un programme, le code était alors lui aussi écrit sur des cartes perforées. </p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/carte_perforee_cobol.jpg" class="img-fluid figure-img"></p>
<figcaption>Carte perforée contenant la ligne d’instruction “IF MOD-G-JAHR NOT NUMERIC MOVE ZERO TO MOD-G-JAHR”, écrite en COBOL, 1959</figcaption>
</figure>
</div>
<p>La question que l’on se pose alors est “Comment ces instructions, sous forme de lettres, permettent à des circuits électriques de faire des calculs ?” </p>
<p>Pour comprendre cela, il faut d’abord expliquer comment les commandes d’un langage de programmation sont lues par l’ordinateur.</p>
<p>Prenons la commande R suivante : print(“Hello World!”) Lorsque l’on va demander à l’ordinateur d’exécuter cette ligne, il va d’abord la traduire en code machine, composé de 0 et de 1 : c’est la <em>compilation</em>. Le code machine est illisible pour les humains, mais est en fait la traduction du code en <em>Assembleur</em> : un langage partagé par tous les processeurs, et qui décompose chaque fonction en une suite d’instructions basiques. &gt; Cette explication est très simplifiée, mais il serait trop complexe de tout détailler ici</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Les bits
</div>
</div>
<div class="callout-body-container callout-body">
<p>Ce que l’on appelle “0 et 1” sont des bits : la plus petite unité d’information possible. Dans un circuit électrique 1 = du courant électrique qui passe, 0 = un courant très faible</p>
</div>
</div>
<div>

</div>
<div class="quarto-layout-panel" data-layout-nrow="1">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 33.3%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/hello_world.png" class="img-fluid figure-img"></p>
<figcaption>Une commande écrite en R, s’exécutant en 39 microsecondes (0.000039 s)</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 33.3%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/assembly.png" class="img-fluid figure-img"></p>
<figcaption>Le même code, en assembleur</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 33.3%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/code_machine.png" class="img-fluid figure-img"></p>
<figcaption>Le même code, en langage machine</figcaption>
</figure>
</div>
</div>
</div>
</div>
<p>MOV, RAX ou RDI sont des “opcodes” (Operation Code) : ce sont des instructions très simples, envoyées au processeur. Un peu à la manière des codons dans l’ADN, ils indiquent ce qui vient après eux. Par exemple, un codon d’initiation dans l’ADN indique le début d’une séquence codante et initialise la traduction de ce qui vient après, jusqu’à rencontrer un codon STOP. Ici, l’opcode MOV sera toujours suivi d’un autre opcode, et RAX est toujours suivi d’une valeur : c’est comme cela qu’on peut traduire des instructions en une suite de 0 et 1</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/adn.jpg" class="img-fluid figure-img"></p>
<figcaption>Traduction de l’ADN à partir du codon d’initation AUG</figcaption>
</figure>
</div>
<blockquote class="blockquote">
<p>Les OPCODES sont comme des codons : ils indiquent une action. 0 et 1 sont comme les nucléotides Tout comme les nucléotides sont regroupés par 3 pour former des acides aminés, les <em>bits</em> (0 et 1) se rassemblent par groupes (souvent de 8) pour former des octets.</p>
</blockquote>
<section id="le-binaire" class="level3">
<h3 class="anchored" data-anchor-id="le-binaire">Le binaire</h3>
<p>Pour bien comprendre comment des instructions comme “MOV”,“RAX” ou des valeurs comme 20 ou 60 sont transformées et lues sous formes de bits, il faut comprendre le système binaire. </p>
<p>Au quotidien, on utilise le système décimal : 10 chiffres (0 à 9), puis on passe à une dizaine (10). Le système binaire fonctionne de la même manière, mais n’utilise que 1 et 0. Ainsi, pour compter 0,1,2,3,4,5 en binaire cela donne 0,1,10,11,100,101. On peut visualiser plus facilement ce système avec des cases :</p>
<p><img src="images/binaire.png" class="img-fluid"> Pour stocker des informations, les bits sont regroupés par paquets appelés “multiplets”. Le plus utilisé est le multiplet de 8 bits : l’octet. Sur l’image ci-dessus, on voit l’octet 00000000. Chaque case correspond à une valeur décimale qui correspond à une dizaine supplémentaire en binaire. Pour écrire le nombre 20, la seule manière de l’écrire ici est 16+4, donc “0-0-0-1-0-1-0-0” =&gt; 00010100</p>
<p>Le code machine fonctionne ainsi : on sait qu’il fonctionne toujours par un opcode, qui indique ce qui le suivra (un opcode ou une valeur), et chaque groupe de 8 bits compose une brique d’information. &gt; Exemple : le code 01101010 00010100 correspond à l’opcode PUSH (garder une valeur en mémoire), suivi de la valeur 20.</p>
<p>Se pose alors une dernière question : comment un opcode peut indiquer à un circuit électrique ce qu’il doit faire des informations données ?</p>
</section>
<section id="les-transistors-et-portes-logiques" class="level3">
<h3 class="anchored" data-anchor-id="les-transistors-et-portes-logiques">Les transistors et portes logiques</h3>
<p><img src="images/logical_doors.png" class="img-fluid"></p>
</section>
</section>
</section>
</div>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>