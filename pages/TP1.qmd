---
title: "TP 1"
format: live-html
engine: knitr
webr:
  packages: 
    - dplyr
    - medicaldata
    - gt
    - forcats
    - GWalkR
toc: true
---

{{< include /_extensions/r-wasm/live/_knitr.qmd >}}

# Documents  

![](./../documents/Cytomegalovirus Dataset Introduction.pdf){width=100% height=800}

# Problématique  

La greffe de cellules souches hématopoïétiques (*HSCT*) est une thérapies des hémopathies malignes (leucémies, lymphomes, myélomes) et à d'autres troubles hématologiques (p. ex., déficit immunitaire primitif, aplasie médullaire, myélodysplasie). La greffe de cellules souches hématopoïétiques est aussi parfois utilisée pour les tumeurs solides (p. ex., certaines tumeurs des cellules germinales) qui répondent à la chimiothérapie.

Cette greffe permet la restauration de moelle osseuse après des traitements myéloablatifs contre le cancer, ou le remplacement de la moelle osseuse anormale par une saine.

L'une des principales complications de cette greffe est l'infection au cytomégalovirus (CMV). Chez la plupart des gens, l'infection au CMV est quasiment invisible, car asymptomatique, et des gens peuvent vivre avec un virus "dormant" durant de nombreuses années. Ainsi, la plupart des porteurs ignorent qu'ils sont infectés. Cependant chez les femmes enceintes ou les personnes avec un système immunitaire affaibli, l'infection peut être fatale. 

Dans le cas où un patient serait porteur asymptomatique du virus, puis subirait une immunosuppression dans le cadre d'un traitement, il existe une possibilité de réaction du virus, provoquant une surmortalité des patients concernés.

Les cellules NK (*Natural Killer*) et les lymphocytes T jouent un rôle de protection contre la réactivation du CMV. La réactivité de ces cellules est régulée par l'interaction des KIRs (*Killer Immunoglobulin-like Receptor*, un récepteur présent sur la membrane des NK) avec les cellules HLA de classe 1 (le système HLA permet de différencier les cellules du soi et les corps étrangers). Le gène producteur des KIRs est fortement *polymorphique* (il en existe différentes versions).

Une hypothèse est que le génotype KIR du donneur a un impact sur la réactivation du CMV après une HSCT.


# Objectif du TP  

- Lire les documents et comprendre la problématique

- Explorer le jeu de données

- Réaliser des statistiques simples sur le jeu de données (moyenne, min, max, différences)

- Identifier les variables d'intérêt pour répondre à la question d'étude

- Trouver une méthodologie qui permettrait de parvenir à une conclusion

- Répondre à l'hypothèse de départ


# Les données  

```{webr data}
#| echo: false
#| persistent: true

library(medicaldata)
gt::gt(cytomegalovirus) %>%
  opt_interactive()
```


![](./../documents/Cytomegalovirus Data Dictionary.pdf){width=100% height=800}


# Exercices

La fonction group_by() permet de "découper" en data.frame en regroupant toutes les lignes dont la valeur est la même pour une colonne définie.
La fonction summarize() est une fonction d'aggrégation, qui permet de créér un nouveau jeu de données où chaque colonne est l'aggrégation d'une autre.
Exemple : 

```{webr}
# obtenir la moyenne de Sepal.Length et Petal.Length
iris %>%
  summarize(mean_sepal_length = mean(Sepal.Length),
            mean_petal_length = mean(Petal.Length)
            )

# Même chose, mais par espèce
iris %>% 
  group_by(Species) %>%
  summarize(mean_sepal_length = mean(Sepal.Length),
            mean_petal_length = mean(Petal.Length)
  )
```


## Exercice 1 : Explorer les données

::: {.callout-note}
Le jeu de données s'appelle `cytomegalovirus`, mais pour faire court, on appellera l'objet `cyto` dans les exercices
:::

```{webr}
#| include: false
cyto <- cytomegalovirus
```


La fonction count() permet d'afficher le nombre de lignes d'un jeu de données. Si on lui donne le nom d'une colonne en argument, elle affiche le nombre de ligne pour chaque valeur différente de cette colonne.

**Affichez le nombre d'hommes et de femmes**

```{webr}
#| exercise: exo_1
______ %>% 
  count(_____)
```

```{webr}
#| exercise: exo_1
#| check: true
if (identical(.result, cyto %>% count(sex))) {
  list(correct = TRUE, message = "Correct !")
} else {
  list(correct = FALSE, message = "Erreur !")
}
```

Avec les fonctions group_by() et summarize() vues plus tôt, **affichez le minimum, le maximum et la moyenne d'âge par sexe**

```{webr}
#| exercise: exo_2
______ %>% 
  _____(_____) %>%
  _____(min = _____(_____),
        max = _____(_____),
        mean = _____(_____)
        )
```

```{webr}
#| exercise: exo_2
#| check: true
if (identical(
  .result, 
  cyto %>% 
  group_by(sex) %>%
  summarize(min = min(age),
            max = max(age),
            mean = mean(age)
  )
)) {
  list(correct = TRUE, message = "Correct !")
} else {
  list(correct = FALSE, message = "Erreur !")
}
```


## Exercice 2 : Nettoyer les données 

La fonction summary(), utilisée sur un dataframe, permet de visualiser de nombreuses informations sur un jeu de données.

```{webr}
summary(cyto)
```

Problème : on remarque que des variables comme le sexe ou l'ethnie sont codées en 0/1 et apparaissent comme des valeurs numériques.
On souhaite recoder ces variables dans la classe `factor`. \n

Un vecteur de classe *factor* contient des valeurs appartenant à une liste pré-établie (pas du texte libre, donc). On attribue une valeur arbitraire à chaque réponse, et les données sont stockées au format numérique.
Par exemple, pour coder la variable *sex* en factor, R attribuera la valeur 1 à la première valeur qui apparait, puis 2, etc... On aura par exemple 1 = "Femme" et 2 = "Homme", avec un vecteur contenant les valeurs c(1,2,2,2,1,1,2,1,2,1,2).
Le vecteur contient donc des nombres, mais qui ne sont pas considérés comme des valeurs numériques.

Pour modifier la colonne d'un dataframe, on utilise la fonction mutate(), généralement avec : 

```{webr}
#| persist: false
cyto <- cyto %>% mutate(sex = as.factor(sex))
```

Mais lorsque l'on souhaite modifier plusieurs colonnes d'un coup, on peut utiliser la variante mutate_at().
Cette fonction prend deux arguments : un vecteur de classe `character` contenant la liste des colonnes à modifier, et le nom de la fonction à appliquer


**Consigne : A partir du dictionnaire des données, identifiez les variables de classe `facteur`, et modifiez-les pour avoir un summary() pertinent**

```{webr}
#| persist: true
#| exercise: exo_3
cyto <- cyto %>%
  mutate_at(
    c(___,____, ...),
    as.factor
  )

summary(cyto)

```


```{webr}
#| exercise: exo_3
#| check: true
#| persist: true
if (identical(
  .result, 
  summary(cyto %>% 
          mutate_at(c("sex", "race", 
                      "diagnosis.type", "prior.radiation", 
                      "prior.transplant", "recipient.cmv",
                      "donor.cmv", "C1/C2",
                      "cmv", "agvhd", "cgvhd"
                      ), 
                    as.factor
                    )
  )
)) {
  list(correct = TRUE, message = "Correct !")
} else {
  list(correct = FALSE, message = "Erreur !")
}
```


Le résultat du summary() est désormais plus clair, mais on souhaite avoir dans le résultat le `label` des variables *factor*. Pour cela, on utilisera le package {forcats}.

```{webr}
library(forcats)

clean_cyto <- cyto %>%
  mutate(sex = fct_recode(sex, Femme = "0", Homme = "1"),
         ____ = ____(____, _____)
         )

summary(clean_cyto)
```

## Exercice 3 : Visualiser les données  

Le package {ggplot2} permet de générer des graphes à partir des données d'un dataframe.
La fonction ggplot() fonctionne par "couches", ou *layers* : on commence par créer les coordonnées (axe X,Y), puis on définit les points/lignes à afficher
dans ggplot(), on utilise la fonction aes() (pour *aesthetics*) pour définir les axes, et on définit ensuite le type de graphe à afficher avec les fonctions geom_* (geom_point, geom_line, geom_histogram...)

**Visualiser le temps de réactivation en fonction des aKIRs, par statut du donneur**


```{webr}
#| exercise: exo_4
library(ggplot2)

clean_cyto %>% 
  ggplot(
    mapping = aes(
      x = _____,
      y = _____,
      color = _____
    )
  ) +
  geom_point() +
  geom_smooth(method = "lm")

```

```{webr}
#| exercise: exo_4
#| check: true
if (identical(
  .result, 
  cyto %>% 
  ggplot(
    mapping = aes(
      x = aKIRs,
      y = time.to.cmv,
      color = donor.cmv
    )
  ) +
  geom_point() +
  geom_smooth(method = "lm")
)) {
  list(correct = TRUE, message = "Correct !")
} else {
  list(correct = FALSE, message = "Erreur !")
}
```

Une façon plus interactive de visualiser les données est d'utiliser le package {GWalkR} :

```{webr}
library(GWalkR)
gwalkr(clean_cyto)
```



## Test statistique

On souhaite réaliser un t.test pour savoir si les KIRs évoluent en fonction du statut cmv :

```{webr}
t.test(aKIRs ~ cmv, data = cytomegalovirus) 
```









# Sources :  

[Transplantation de cellules-souches hématopoïétiques](https://www.msdmanuals.com/fr/professional/immunologie-troubles-allergiques/transplantation/transplantation-de-cellules-souches-h%C3%A9matopo%C3%AF%C3%A9tiques)

[Expert consensus on the management of cytomegalovirus infection in pediatric allogeneic hematopoietic stem cell transplantation](https://www.sciencedirect.com/science/article/pii/S2452318625000443)

[The extensive polymorphism of KIR genes](https://pubmed.ncbi.nlm.nih.gov/20028428/)


